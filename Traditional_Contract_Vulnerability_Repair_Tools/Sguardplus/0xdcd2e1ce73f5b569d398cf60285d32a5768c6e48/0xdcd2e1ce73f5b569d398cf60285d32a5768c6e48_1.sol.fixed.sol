pragma solidity ^0.4.19;

                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function add_uint(uint a, uint b) internal pure returns (uint) {
                                uint c = a + b;
                                assert(c >= a);
                                return c;
                        }
function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                uint256 c = a + b;
                                assert(c >= a);
                                return c;
                        }
                                
                                
                                
                        }
                contract timelock is sGuardPlus {
uint  public   freezeBlocks = 200000;
struct locker {
uint     freedom;
uint     bal;
}
mapping (address  => locker ) public   lockers;
event Locked (address  indexed  locker,uint  indexed  amount);
event Released (address  indexed  locker,uint  indexed  amount);
function () public payable {
locker    storage l = lockers[msg.sender];
l.freedom=add_uint(block.number, freezeBlocks);
l.bal=add_uint256(l.bal, msg.value);
Locked(msg.sender, msg.value);
}

function withdraw () public  {
locker    storage l = lockers[msg.sender];
require(block.number>l.freedom&&l.bal>0);
uint     value = l.bal;
l.bal=0;
msg.sender.transfer(value);
Released(msg.sender, value);
}

}
