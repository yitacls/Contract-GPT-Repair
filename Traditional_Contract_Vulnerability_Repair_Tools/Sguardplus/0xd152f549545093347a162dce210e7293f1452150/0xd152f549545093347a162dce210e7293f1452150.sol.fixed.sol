
                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                uint256 c = a + b;
                                assert(c >= a);
                                return c;
                        }
                                
                                
                                
                        }
                interface IERC20  {
function transfer (address    to,uint256    value) external  returns (bool    );
function transferFrom (address    from,address    to,uint256    value) external  returns (bool    );
}
contract Disperse is sGuardPlus {
function disperseEther (address []   recipients,uint256 []   values) external payable {
for(uint256     i = 0;i<recipients.length; i=add_uint256(i, 1))recipients[i].transfer(values[i]);

uint256     balance = address(this).balance;
if (balance>0)
msg.sender.transfer(balance);

}

function disperseToken (IERC20    token,address []   recipients,uint256 []   values) external  {
uint256     total = 0;
for(uint256     i = 0;i<recipients.length; i=add_uint256(i, 1))total=add_uint256(total, values[i]);

require(token.transferFrom(msg.sender, address(this), total));
for(i=0;i<recipients.length; i=add_uint256(i, 1))require(token.transfer(recipients[i], values[i]));

}

function disperseTokenSimple (IERC20    token,address []   recipients,uint256 []   values) external  {
for(uint256     i = 0;i<recipients.length; i=add_uint256(i, 1))require(token.transferFrom(msg.sender, recipients[i], values[i]));

}

}
