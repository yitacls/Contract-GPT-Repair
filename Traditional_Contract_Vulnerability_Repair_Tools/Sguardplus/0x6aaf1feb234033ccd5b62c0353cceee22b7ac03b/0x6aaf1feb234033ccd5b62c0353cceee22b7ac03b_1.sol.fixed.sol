pragma solidity ^0.4.21;

                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                assert(b <= a);
                                return a - b;
                        }
function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                uint256 c = a + b;
                                assert(c >= a);
                                return c;
                        }
                                
                                
                                
                        }
                contract BtsvcToken is sGuardPlus {
mapping (address  => uint256 ) public   balanceOf;
string  public   name = "BTSVC ERC20 Token";
string  public   symbol = "BTSVC";
uint8  public   decimals = 6;
uint256  public   totalSupply = 210000000000000000;
event Transfer (address  indexed  from,address  indexed  to,uint256    value);
constructor () public  {
balanceOf[msg.sender]=totalSupply;
emit Transfer(address(0), msg.sender, totalSupply);
}

function transfer (address    to,uint256    value) public  returns (bool    success){
require(balanceOf[msg.sender]>=value);
balanceOf[msg.sender]=sub_uint256(balanceOf[msg.sender], value);
balanceOf[to]=add_uint256(balanceOf[to], value);
emit Transfer(msg.sender, to, value);
return true;
}

event Approval (address  indexed  owner,address  indexed  spender,uint256    value);
mapping (address  => mapping (address  => uint256 )) public   allowance;
function approve (address    spender,uint256    value) public  returns (bool    success){
allowance[msg.sender][spender]=value;
emit Approval(msg.sender, spender, value);
return true;
}

function transferFrom (address    from,address    to,uint256    value) public  returns (bool    success){
require(value<=balanceOf[from]);
require(value<=allowance[from][msg.sender]);
balanceOf[from]-=value;
balanceOf[to]+=value;
allowance[from][msg.sender]-=value;
emit Transfer(from, to, value);
return true;
}

}
