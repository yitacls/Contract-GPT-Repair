pragma solidity ^0.4.16;

                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function div_uint(uint a, uint b) internal pure returns (uint) {
                                uint c = a / b;
                                return c;
                        }
function mul_uint(uint a, uint b) internal pure returns (uint) {
                                if (a == 0) {
                                        return 0;
                                }
                                uint c = a * b;
                                assert(c / a == b);
                                return c;
                        }
                                
                                
                                
                        }
                interface token  {
function transfer (address    receiver,uint    amount) public  ;
}
contract Presale is sGuardPlus {
address  public   beneficiary;
address  public   burner;
uint  public   fundingGoal;
uint  public   amountRaised;
uint  public   deadline;
uint  public   pricePresale = 10000;
uint  public   presaleSupply = 6120000*1 ether;
uint  public   availableSupply = 4000000*1 ether;
uint  public   erotixFundMultiplier = 50;
uint  public   foundersFundMultiplier = 3;
uint  public   requestedTokens;
uint  public   amountAvailable;
address  public   erotixFund = 0x1a0cc2B7F7Cb6fFFd3194A2AEBd78A4a072915Be;
address  public   foundersFund = 0xaefe05643b613823dBAF6245AFb819Fd56fBdd22;
token  public   tokenReward;
mapping (address  => uint256 ) public   balanceOf;
bool     fundingGoalReached = false;
bool     presaleClosed = false;
event GoalReached (address    recipient,uint    totalAmountRaised);
event FundTransfer (address    backer,uint    amount,bool    isContribution);
constructor (address    ifSuccessfulSendTo,uint    fundingGoalInEthers,uint    endOfPresale,address    addressOfTokenUsedAsReward,address    burnAddress) public  {
beneficiary=ifSuccessfulSendTo;
fundingGoal=fundingGoalInEthers*1 ether;
deadline=endOfPresale;
tokenReward=token(addressOfTokenUsedAsReward);
burner=burnAddress;
}

function () public payable {
require( ! presaleClosed);
uint     amount = msg.value;
requestedTokens=amount*pricePresale;
if (requestedTokens<=availableSupply)
{
balanceOf[msg.sender]+=amount;
amountRaised+=amount;
tokenReward.transfer(msg.sender, amount*pricePresale);
tokenReward.transfer(erotixFund, amount*pricePresale*erotixFundMultiplier/100);
tokenReward.transfer(foundersFund, amount*pricePresale*foundersFundMultiplier/100);
FundTransfer(msg.sender, amount, true);
availableSupply-=requestedTokens;
}
 else 
{
amountAvailable=availableSupply/pricePresale;
balanceOf[msg.sender]+=amountAvailable;
amountRaised+=amountAvailable;
tokenReward.transfer(msg.sender, amountAvailable*pricePresale);
tokenReward.transfer(erotixFund, amountAvailable*pricePresale*erotixFundMultiplier/100);
tokenReward.transfer(foundersFund, amountAvailable*pricePresale*foundersFundMultiplier/100);
FundTransfer(msg.sender, amountAvailable, true);
availableSupply=0;
amount-=amountAvailable;
bool     __sent_result101 = msg.sender.send(amount);
require(__sent_result101);
presaleClosed=true;
}

}

modifier afterDeadline (){
if (now>=deadline)
_;

}
function checkGoalReached () public afterDeadline  {
if (amountRaised>=fundingGoal)
{
fundingGoalReached=true;
GoalReached(beneficiary, amountRaised);
}

presaleClosed=true;
if (availableSupply>0)
{
tokenReward.transfer(burner, availableSupply);
tokenReward.transfer(burner, div_uint(mul_uint(availableSupply, erotixFundMultiplier), 100));
tokenReward.transfer(burner, div_uint(mul_uint(availableSupply, foundersFundMultiplier), 100));
}

}

function safeWithdrawal () public  {
if (now>=deadline)
{
if ( ! fundingGoalReached)
{
uint     amount = balanceOf[msg.sender];
balanceOf[msg.sender]=0;
if (amount>0)
{
if (msg.sender.send(amount))
{
FundTransfer(msg.sender, amount, false);
}
 else 
{
balanceOf[msg.sender]=amount;
}

}

}

}

if (presaleClosed)
{
if (fundingGoalReached&&beneficiary==msg.sender)
{
if (beneficiary.send(amountRaised))
{
FundTransfer(beneficiary, amountRaised, false);
}
 else 
{
fundingGoalReached=false;
}

}

}

}

}
