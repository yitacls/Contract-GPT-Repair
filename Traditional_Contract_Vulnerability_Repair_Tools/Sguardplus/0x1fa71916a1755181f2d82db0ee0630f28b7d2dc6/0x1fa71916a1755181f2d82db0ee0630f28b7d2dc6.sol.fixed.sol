pragma solidity ^0.4.13;

                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                assert(b <= a);
                                return a - b;
                        }
function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                uint256 c = a + b;
                                assert(c >= a);
                                return c;
                        }
                                
                                
                                
                        }
                contract BankhadCoin is sGuardPlus {
address  public   owner;
string  public   name;
string  public   symbol;
uint8  public   decimals;
uint256  public   totalSupply;
mapping (address  => uint256 ) public   balanceOf;
mapping (address  => mapping (address  => uint256 )) public   allowance;
event Transfer (address  indexed  from,address  indexed  to,uint256    value);
event Burn (address  indexed  from,uint256    value);
constructor ()   {
owner=0xaCa0B051C98B1667B9211aB4A4Cb8CFF03d755Bb;
name="Bankhad Coin";
symbol="BAK";
decimals=18;
totalSupply=10000000000000000000000000000;
balanceOf[owner]=10000000000000000000000000000;
}

function transfer (address    _to,uint256    _value)   returns (bool    success){
require(balanceOf[msg.sender]>=_value);
balanceOf[msg.sender]=sub_uint256(balanceOf[msg.sender], _value);
balanceOf[_to]=add_uint256(balanceOf[_to], _value);
Transfer(msg.sender, _to, _value);
return true;
}

function approve (address    _spender,uint256    _value)   returns (bool    success){
allowance[msg.sender][_spender]=_value;
return true;
}

function transferFrom (address    _from,address    _to,uint256    _value)   returns (bool    success){
require(balanceOf[_from]>=_value);
require(allowance[_from][msg.sender]>=_value);
balanceOf[_from]=sub_uint256(balanceOf[_from], _value);
balanceOf[_to]=add_uint256(balanceOf[_to], _value);
allowance[_from][msg.sender]=sub_uint256(allowance[_from][msg.sender], _value);
Transfer(_from, _to, _value);
return true;
}

function burn (uint256    _value)   returns (bool    success){
require(balanceOf[msg.sender]>=_value);
balanceOf[msg.sender]-=_value;
totalSupply-=_value;
Burn(msg.sender, _value);
return true;
}

function burnFrom (address    _from,uint256    _value)   returns (bool    success){
require(balanceOf[_from]>=_value);
require(msg.sender==owner);
balanceOf[_from]-=_value;
totalSupply-=_value;
Burn(_from, _value);
return true;
}

}
