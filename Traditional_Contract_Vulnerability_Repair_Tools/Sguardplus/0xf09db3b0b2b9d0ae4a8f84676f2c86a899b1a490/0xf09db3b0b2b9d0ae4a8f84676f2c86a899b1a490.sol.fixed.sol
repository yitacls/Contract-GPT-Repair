pragma solidity ^0.4.24;

                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function div_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                uint256 c = a / b;
                                return c;
                        }
function mul_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                if (a == 0) {
                                        return 0;
                                }
                                uint256 c = a * b;
                                assert(c / a == b);
                                return c;
                        }
                                
                                
                                
                        }
                contract ERC20  {
function totalSupply () public constant returns (uint    );
function balanceOf (address    tokenOwner) public constant returns (uint    balance);
function allowance (address    tokenOwner,address    spender) public constant returns (uint    remaining);
function transfer (address    to,uint    tokens) public  returns (bool    success);
function approve (address    spender,uint    tokens) public  returns (bool    success);
function transferFrom (address    from,address    to,uint    tokens) public  returns (bool    success);
event Transfer (address  indexed  from,address  indexed  to,uint    tokens);
event Approval (address  indexed  tokenOwner,address  indexed  spender,uint    tokens);
}
contract ReservedContract is sGuardPlus {
address  public   richest;
address  public   owner;
uint  public   mostSent;
uint256     tokenPrice = 1;
ERC20     Paytoken;
address  public   _reserve20 = 0xD73a0D08cCa496fC687E6c7F4C3D66234FEfda47;
event PackageJoinedViaPAD (address    buyer,uint    amount);
event PackageJoinedViaETH (address    buyer,uint    amount);
mapping (address  => uint )    pendingWithdraws;
modifier onlyAdmin (){
require(msg.sender==owner);
_;
}
function setPayanyToken (address    _PayToken) public onlyAdmin  {
Paytoken=ERC20(_PayToken);
}

function withdrawETH (uint    amount) public onlyAdmin  returns (bool    ){
require(amount<=this.balance);
owner.transfer(amount);
return true;
}

function withdrawToken (address    h0dler,uint    amount) public onlyAdmin  returns (bool    ){
require(amount<=Paytoken.balanceOf(h0dler));
bool     __sent_result100 = Paytoken.transfer(msg.sender, amount);
require(__sent_result100);
return true;
}

function setPrices (uint256    newTokenPrice) public onlyAdmin  {
tokenPrice=newTokenPrice;
}

constructor () public payable {
richest=msg.sender;
mostSent=msg.value;
owner=msg.sender;
}

function becomeRichest ()  payable returns (bool    ){
require(msg.value>mostSent);
pendingWithdraws[richest]+=msg.value;
richest=msg.sender;
mostSent=msg.value;
return true;
}

function joinPackageViaETH (uint    _amount) public payable {
require(_amount>=0);
_reserve20.transfer(div_uint256(mul_uint256(msg.value, 20), 100));
emit PackageJoinedViaETH(msg.sender, msg.value);
}

function joinPackageViaPAD (uint    _amount) public  {
require(_amount>=0);
bool     __sent_result101 = Paytoken.transfer(_reserve20, msg.value*20/100);
require(__sent_result101);
emit PackageJoinedViaPAD(msg.sender, msg.value);
}

function getBalanceContract () public constant returns (uint    ){
return this.balance;
}

function getTokenBalanceOf (address    h0dler) public constant returns (uint    balance){
return Paytoken.balanceOf(h0dler);
}

}
