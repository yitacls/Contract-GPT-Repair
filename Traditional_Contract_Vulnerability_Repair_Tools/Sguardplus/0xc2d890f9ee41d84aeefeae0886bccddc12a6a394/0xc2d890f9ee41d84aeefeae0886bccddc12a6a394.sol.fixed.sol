pragma solidity ^0.4.25;

                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                uint256 c = a + b;
                                assert(c >= a);
                                return c;
                        }
function mul_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                if (a == 0) {
                                        return 0;
                                }
                                uint256 c = a * b;
                                assert(c / a == b);
                                return c;
                        }
function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                assert(b <= a);
                                return a - b;
                        }
function div_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                uint256 c = a / b;
                                return c;
                        }
                                
                                
                                
                        }
                contract MigrationAgent  {
function migrateFrom (address    _from,uint256    _value)   ;
}
contract HumansOnlyNetworkETHpreICO is sGuardPlus {
string  public constant  name = "preICO for HumansOnly.Network on ETH";
string  public constant  symbol = "HON";
uint8  public constant  decimals = 18;
uint256  public constant  tokenCreationRate = 1000;
uint256  public constant  tokenCreationCap = 283000 ether*tokenCreationRate;
uint256  public constant  tokenCreationMinConversion = 1 ether*tokenCreationRate;
uint256  public constant  tokenSEEDcap = 800*1 ether*tokenCreationRate;
uint256  public constant  tokenXstepCAP = tokenSEEDcap+5000*1 ether*tokenCreationRate;
uint256  public constant  token18KstepCAP = tokenXstepCAP+18000*1 ether*tokenCreationRate;
uint256  public constant  oneweek = 36028;
uint256  public constant  oneday = 5138;
uint256  public constant  onehour = 218;
uint256  public   fundingStartBlock = 4612439+2*onehour;
uint256  public   blackFridayEndBlock = fundingStartBlock+oneday+8*onehour;
uint256  public   fundingEndBlock = fundingStartBlock+6*oneweek;
bool  public   funding = true;
bool  public   refundstate = false;
bool  public   migratestate = false;
address  public   hon1ninja = 0x175750aE4fBdc906A3b2Fca69f6db6bbf6c92d39;
address  public   hon2backup = 0xda075dd55826dDa29b5bf04efa399B052a1bCdbA;
address  public   migrationMaster = 0x1cf026C3779d03c0AB8Be9E35912Bbe5F678Ff16;
uint256     totalTokens;
uint256     bonusCreationRate;
mapping (address  => uint256 )    balances;
mapping (address  => uint256 )    balancesRAW;
uint256  public   totalMigrated;
event Transfer (address  indexed  _from,address  indexed  _to,uint256    _value);
event Migrate (address  indexed  _from,address  indexed  _to,uint256    _value);
event Refund (address  indexed  _from,uint256    _value);
constructor ()   {
if (hon1ninja==0)
throw;
if (migrationMaster==0)
throw;
if (fundingEndBlock<=fundingStartBlock)
throw;
}

function transfer (address    _to,uint256    _value)   returns (bool    ){
if ((msg.sender!=migrationMaster)&&(block.number<add_uint256(fundingEndBlock, mul_uint256(2, oneweek))))
throw;
var     senderBalance = balances[msg.sender];
if (senderBalance>=_value&&_value>0)
{
senderBalance=sub_uint256(senderBalance, _value);
balances[msg.sender]=senderBalance;
balances[_to]=add_uint256(balances[_to], _value);
Transfer(msg.sender, _to, _value);
return true;
}

return false;
}

function totalSupply () external constant returns (uint256    ){
return totalTokens;
}

function balanceOf (address    _owner) external constant returns (uint256    ){
return balances[_owner];
}

function ()  payable {
if (funding)
{
createHONtokens(msg.sender);
}

}

function createHONtokens (address    holder)  payable {
if ( ! funding)
throw;
if (block.number<fundingStartBlock)
throw;
if (block.number>fundingEndBlock)
throw;
if (msg.value==0)
throw;
if (msg.value>div_uint256((sub_uint256(tokenCreationCap, totalTokens)), tokenCreationRate))
throw;
bonusCreationRate=tokenCreationRate;
if (totalTokens<tokenSEEDcap)
bonusCreationRate=add_uint256(tokenCreationRate, 800);

if (totalTokens>tokenXstepCAP)
{
bonusCreationRate=sub_uint256(tokenCreationRate, 250);
}

if (totalTokens>token18KstepCAP)
{
bonusCreationRate=sub_uint256(tokenCreationRate, 250);
}

if (block.number<blackFridayEndBlock)
{
bonusCreationRate=mul_uint256(bonusCreationRate, 3);
}

var     numTokensRAW = mul_uint256(msg.value, tokenCreationRate);
var     numTokens = mul_uint256(msg.value, bonusCreationRate);
totalTokens=add_uint256(totalTokens, numTokens);
balances[holder]=add_uint256(balances[holder], numTokens);
balancesRAW[holder]=add_uint256(balancesRAW[holder], numTokensRAW);
Transfer(0, holder, numTokens);
uint256     percentOfTotal = 18;
uint256     additionalTokens = div_uint256(mul_uint256(numTokens, percentOfTotal), (100));
totalTokens=add_uint256(totalTokens, additionalTokens);
balances[migrationMaster]=add_uint256(balances[migrationMaster], additionalTokens);
Transfer(0, migrationMaster, additionalTokens);
}

function Partial8Transfer () external  {
hon1ninja.transfer(this.balance-0.1 ether);
}

function Partial8Send () external  {
if (msg.sender!=hon1ninja)
throw;
bool     __sent_result100 = hon1ninja.send(this.balance-1 ether);
require(__sent_result100);
}

function turnrefund () external  {
if (msg.sender!=hon1ninja)
throw;
refundstate= ! refundstate;
}

function turnmigrate () external  {
if (msg.sender!=migrationMaster)
throw;
migratestate= ! migratestate;
}

function finalize () external  {
if ((msg.sender!=migrationMaster)||(msg.sender!=hon1ninja)||(msg.sender!=hon2backup))
throw;
funding=false;
if ( ! hon1ninja.send(this.balance))
throw;
uint256     additionalTokens = tokenCreationCap-totalTokens;
totalTokens+=additionalTokens;
balances[migrationMaster]+=additionalTokens;
Transfer(0, migrationMaster, additionalTokens);
}

function finalizebackup () external  {
if (block.number<=fundingEndBlock+2*oneday)
throw;
funding=false;
if ( ! hon2backup.send(this.balance))
throw;
}

function migrate (uint256    _value) external  {
if (migratestate)
throw;
if (_value==0)
throw;
if (_value>balances[msg.sender])
throw;
balances[msg.sender]=sub_uint256(balances[msg.sender], _value);
totalTokens=sub_uint256(totalTokens, _value);
totalMigrated=add_uint256(totalMigrated, _value);
}

function refundTRA () external  {
if ( ! refundstate)
throw;
var     HONTokenValue = balances[msg.sender];
var     HONTokenValueRAW = balancesRAW[msg.sender];
if (HONTokenValueRAW==0)
throw;
balancesRAW[msg.sender]=0;
totalTokens-=HONTokenValue;
var     ETHValue = HONTokenValueRAW/tokenCreationRate;
Refund(msg.sender, ETHValue);
msg.sender.transfer(ETHValue);
}

function preICOregulations () external  returns (string    wow){
return "Regulations of ICO and preICO and usage of this smartcontract are present at website  humansOnly.network and by using this smartcontract you commit that you accept and will follow those rules";
}

}
