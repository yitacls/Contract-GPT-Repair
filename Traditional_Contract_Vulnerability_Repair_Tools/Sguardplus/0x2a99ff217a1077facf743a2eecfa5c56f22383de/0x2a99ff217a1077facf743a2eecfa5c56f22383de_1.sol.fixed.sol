pragma solidity ^0.4.16;

                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                uint256 c = a + b;
                                assert(c >= a);
                                return c;
                        }
function add_uint(uint a, uint b) internal pure returns (uint) {
                                uint c = a + b;
                                assert(c >= a);
                                return c;
                        }
                                
                                
                                
                        }
                interface token  {
function transfer (address    receiver,uint    amount)   ;
}
contract Crowdsale is sGuardPlus {
uint  public   createdTimestamp;
uint  public   start;
uint  public   deadline;
address  public   beneficiary;
uint  public   amountRaised;
mapping (address  => uint256 ) public   balanceOf;
bool     crowdsaleClosed = false;
event FundTransfer (address    backer,uint    amount,bool    isContribution);
constructor ()   {
createdTimestamp=block.timestamp;
start=1526292000;
deadline=1529143200;
amountRaised=0;
beneficiary=0xDfD0500541c6F14eb9eD2A6e61BB63bc78693925;
}

function ()  payable {
require(block.timestamp>=start&&block.timestamp<=deadline&&amountRaised<(6000 ether));
uint     amount = msg.value;
balanceOf[msg.sender]=add_uint256(balanceOf[msg.sender], amount);
amountRaised=add_uint(amountRaised, amount);
FundTransfer(msg.sender, amount, true);
if (beneficiary.send(amount))
{
FundTransfer(beneficiary, amount, false);
}

}

}
