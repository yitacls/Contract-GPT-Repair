pragma solidity ^0.4.16;

                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                assert(b <= a);
                                return a - b;
                        }
function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
                                uint256 c = a + b;
                                assert(c >= a);
                                return c;
                        }
                                
                                
                                
                        }
                contract USDC is sGuardPlus {
uint256  private constant  MAX_UINT256 = 2**256-1;
mapping (address  => uint256 ) public   balances;
mapping (address  => mapping (address  => uint256 )) public   allowed;
uint256  public   totalSupply;
string  public   name;
uint8  public   decimals;
string  public   symbol;
event Transfer (address  indexed  _from,address  indexed  _to,uint256    _value);
event Approval (address  indexed  _owner,address  indexed  _spender,uint256    _value);
constructor () public  {
balances[msg.sender]=15800000000000;
totalSupply=15800000000000;
name="USDC";
decimals=4;
symbol="USDC";
}

function transfer (address    _to,uint256    _value) public  returns (bool    success){
require(balances[msg.sender]>=_value);
balances[msg.sender]=sub_uint256(balances[msg.sender], _value);
balances[_to]=add_uint256(balances[_to], _value);
Transfer(msg.sender, _to, _value);
return true;
}

function transferFrom (address    _from,address    _to,uint256    _value) public  returns (bool    success){
uint256     allowance = allowed[_from][msg.sender];
require(balances[_from]>=_value&&allowance>=_value);
balances[_to]=add_uint256(balances[_to], _value);
balances[_from]=sub_uint256(balances[_from], _value);
if (allowance<MAX_UINT256)
{
allowed[_from][msg.sender]=sub_uint256(allowed[_from][msg.sender], _value);
}

Transfer(_from, _to, _value);
return true;
}

function balanceOf (address    _owner) public view returns (uint256    balance){
return balances[_owner];
}

function approve (address    _spender,uint256    _value) public  returns (bool    success){
allowed[msg.sender][_spender]=_value;
Approval(msg.sender, _spender, _value);
return true;
}

function allowance (address    _owner,address    _spender) public view returns (uint256    remaining){
return allowed[_owner][_spender];
}

}
