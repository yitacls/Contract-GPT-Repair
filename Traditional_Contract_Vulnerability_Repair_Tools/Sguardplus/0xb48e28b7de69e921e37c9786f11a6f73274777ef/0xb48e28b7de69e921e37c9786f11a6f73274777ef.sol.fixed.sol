pragma solidity ^0.4.18;

                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function mul_uint(uint a, uint b) internal pure returns (uint) {
                                if (a == 0) {
                                        return 0;
                                }
                                uint c = a * b;
                                assert(c / a == b);
                                return c;
                        }
function add_uint(uint a, uint b) internal pure returns (uint) {
                                uint c = a + b;
                                assert(c >= a);
                                return c;
                        }
                                
                                
                                
                        }
                interface token  {
function transfer (address    receiver,uint    amount)   ;
}
contract Crowdsale is sGuardPlus {
address  public   beneficiary;
uint  public   fundingGoal;
uint  public   amountRaised;
uint  public   deadline;
uint  public   price;
token  public   tokenReward;
mapping (address  => uint256 ) public   balanceOf;
bool     fundingGoalReached = false;
bool     crowdsaleClosed = false;
event GoalReached (address    recipient,uint    totalAmountRaised);
event FundTransfer (address    backer,uint    amount,bool    isContribution);
constructor (address    ifSuccessfulSendTo,uint    fundingGoalInEthers,uint    durationInMinutes,uint    etherCostOfEachToken,address    addressOfTokenUsedAsReward)   {
beneficiary=ifSuccessfulSendTo;
fundingGoal=mul_uint(fundingGoalInEthers, 1 ether);
deadline=add_uint(now, mul_uint(durationInMinutes, 1 minutes));
price=mul_uint(etherCostOfEachToken, 1 ether);
tokenReward=token(addressOfTokenUsedAsReward);
}

function ()  payable {
require( ! crowdsaleClosed);
uint     amount = msg.value;
balanceOf[msg.sender]+=amount;
amountRaised+=amount;
tokenReward.transfer(msg.sender, amount/price);
bool     __sent_result100 = beneficiary.send(amountRaised);
require(__sent_result100);
amountRaised=0;
FundTransfer(msg.sender, amount, true);
}

}
