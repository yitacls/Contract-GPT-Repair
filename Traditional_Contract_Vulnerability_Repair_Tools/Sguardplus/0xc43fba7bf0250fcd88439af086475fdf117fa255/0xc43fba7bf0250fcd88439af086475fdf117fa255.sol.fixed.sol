pragma solidity ^0.4.19;

                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function mul_uint(uint a, uint b) internal pure returns (uint) {
                                if (a == 0) {
                                        return 0;
                                }
                                uint c = a * b;
                                assert(c / a == b);
                                return c;
                        }
function add_uint(uint a, uint b) internal pure returns (uint) {
                                uint c = a + b;
                                assert(c >= a);
                                return c;
                        }
                                
                                
                                
                        }
                interface token  {
function transfer (address    receiver,uint    amount) public  ;
}
contract Crowdsale is sGuardPlus {
address  public   beneficiary;
uint  public   fundingGoal;
uint  public   amountRaised;
uint  public   deadline;
uint  public   price;
token  public   tokenReward;
mapping (address  => uint256 ) public   balanceOf;
bool     fundingGoalReached = false;
bool     crowdsaleClosed = false;
event GoalReached (address    recipient,uint    totalAmountRaised);
event FundTransfer (address    backer,uint    amount,bool    isContribution);
constructor (address    ifSuccessfulSendTo,uint    fundingGoalInEthers,uint    durationInMinutes,uint    etherCostOfEachToken,address    addressOfTokenUsedAsReward) public  {
beneficiary=ifSuccessfulSendTo;
fundingGoal=mul_uint(fundingGoalInEthers, 1 ether);
deadline=add_uint(now, mul_uint(durationInMinutes, 1 minutes));
price=mul_uint(etherCostOfEachToken, 1 ether);
tokenReward=token(addressOfTokenUsedAsReward);
}

function () public payable {
require( ! crowdsaleClosed);
uint     amount = msg.value;
balanceOf[msg.sender]+=amount;
amountRaised+=amount;
tokenReward.transfer(msg.sender, amount/price);
FundTransfer(msg.sender, amount, true);
}

modifier afterDeadline (){
if (now>=deadline)
_;

}
function checkGoalReached () public afterDeadline  {
if (amountRaised>=fundingGoal)
{
fundingGoalReached=true;
GoalReached(beneficiary, amountRaised);
}

crowdsaleClosed=true;
}

function safeWithdrawal () public afterDeadline  {
if ( ! fundingGoalReached)
{
uint     amount = balanceOf[msg.sender];
balanceOf[msg.sender]=0;
if (amount>0)
{
if (msg.sender.send(amount))
{
FundTransfer(msg.sender, amount, false);
}
 else 
{
balanceOf[msg.sender]=amount;
}

}

}

if (fundingGoalReached&&beneficiary==msg.sender)
{
if (beneficiary.send(amountRaised))
{
FundTransfer(beneficiary, amountRaised, false);
}
 else 
{
fundingGoalReached=false;
}

}

}

}
