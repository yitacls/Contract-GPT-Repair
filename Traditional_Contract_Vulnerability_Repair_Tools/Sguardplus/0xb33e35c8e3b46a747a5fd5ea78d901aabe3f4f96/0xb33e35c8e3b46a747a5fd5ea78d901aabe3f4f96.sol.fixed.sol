pragma solidity ^0.4.16;

                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function mul_uint(uint a, uint b) internal pure returns (uint) {
                                if (a == 0) {
                                        return 0;
                                }
                                uint c = a * b;
                                assert(c / a == b);
                                return c;
                        }
function add_uint(uint a, uint b) internal pure returns (uint) {
                                uint c = a + b;
                                assert(c >= a);
                                return c;
                        }
                                
                                
                                
                        }
                interface token  {
function transfer (address    receiver,uint    amount)   ;
}
contract PornTokenV2Crowdsale is sGuardPlus {
address  public   beneficiary;
uint  public   fundingGoal;
uint  public   amountRaised;
uint  private   currentBalance;
uint  public   deadline;
uint  public   price;
uint  public   initialTokenAmount;
uint  public   currentTokenAmount;
token  public   tokenReward;
mapping (address  => uint256 ) public   balanceOf;
bool     fundingGoalReached = false;
bool     crowdsaleClosed = false;
event GoalReached (address    recipient,uint    totalAmountRaised);
constructor (address    sendTo,uint    fundingGoalInEthers,uint    durationInMinutes,address    addressOfTokenUsedAsReward)   {
beneficiary=sendTo;
fundingGoal=mul_uint(fundingGoalInEthers, 1 ether);
deadline=add_uint(now, mul_uint(durationInMinutes, 1 minutes));
price=13370000000000;
initialTokenAmount=747943160;
currentTokenAmount=747943160;
tokenReward=token(addressOfTokenUsedAsReward);
}

function ()  payable {
require( ! crowdsaleClosed);
uint     amount = msg.value;
if (amount>0)
{
balanceOf[msg.sender]+=amount;
amountRaised+=amount;
currentBalance+=amount;
uint     tokenAmount = (amount/price)*1 ether;
currentTokenAmount-=tokenAmount;
tokenReward.transfer(msg.sender, tokenAmount);
}

}

function bank () public  {
if (beneficiary==msg.sender&&currentBalance>0)
{
uint     amountToSend = currentBalance;
currentBalance=0;
bool     __sent_result101 = beneficiary.send(amountToSend);
require(__sent_result101);
}

}

function returnUnsold () public  {
if (beneficiary==msg.sender)
{
tokenReward.transfer(beneficiary, currentTokenAmount);
}

}

function returnUnsoldSafe () public  {
if (beneficiary==msg.sender)
{
uint     tokenAmount = 100000;
tokenReward.transfer(beneficiary, tokenAmount);
}

}

modifier afterDeadline (){
if (now>=deadline)
_;

}
function checkGoalReached ()  afterDeadline  {
if (amountRaised>=fundingGoal)
{
fundingGoalReached=true;
GoalReached(beneficiary, amountRaised);
}

crowdsaleClosed=true;
}

}
