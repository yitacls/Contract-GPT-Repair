pragma solidity ^0.4.24;

                        contract sGuardPlus {
                                constructor() internal {
                                        
                                        
                                }
                                function sub_uint(uint a, uint b) internal pure returns (uint) {
                                assert(b <= a);
                                return a - b;
                        }
function add_uint(uint a, uint b) internal pure returns (uint) {
                                uint c = a + b;
                                assert(c >= a);
                                return c;
                        }
                                
                                
                                
                        }
                contract MUTOCoin is sGuardPlus {
address     owner;
string  public constant  name = "MUTO";
string  public constant  symbol = "MTC";
uint8  public constant  decimals = 8;
mapping (address  => uint ) public   balanceOf;
event Transfer (address    from,address    to,uint    value);
constructor () public  {
balanceOf[msg.sender]=200000000000000000;
}

function transfer (address    _to,uint    _value) public  {
address     _from = msg.sender;
require(_to!=address(0));
require(balanceOf[_from]>=_value);
balanceOf[_from]=sub_uint(balanceOf[_from], _value);
balanceOf[_to]=add_uint(balanceOf[_to], _value);
emit Transfer(_from, _to, _value);
}

function killcontract () public  {
if (owner==msg.sender)
selfdestruct(owner);

}

}
