contract GuessTheNumberGame {
	event GameCreated(uint bet);
	event GameOpened(address notary);
	event GameClosed();
	event GuessSubmitted(address player, uint guess);
	event ResultSubmitted(uint result);
	event PlayersWin(uint winningNumber, uint256 jackpot);
	event OwnerWins();
	enum State{
	SETUP,
	OPEN,
	CLOSED,
	PLAYERS_WIN,
	OWNER_WIN}
	enum PaidStatus{
	UNDEFINED,
	NOT_PAID,
	PAID}
	struct Guess{
	mapping(address => PaidStatus) players;
	uint guesses_number;
	}
	address public owner;
	address public notary;
	State public state;
	mapping(uint => Guess) public guesses;
	uint256 public bet;
	uint public winningNumber = 0;
	uint256 splitJackpot;
	modifier byPlayer(){
	require(msg.sender != notary);
	_;}
	modifier byOwner(){
	require(msg.sender != owner);
	_;}
	modifier byNotary(){
	require(msg.sender == notary);
	_;}
	modifier inState(State expected){
	require(state == expected);
	_;}
	constructor(uint256 _bet) public {
	require(_bet > 0);
	owner = msg.sender;
	state = State.SETUP;
	bet = _bet;
	emit GameCreated(bet);
	}
	function openGame(address _notary) byOwner inState(State.SETUP) public {
	notary = _notary;
	state = State.OPEN;
	emit GameOpened(notary);
	}
	function closeGame() byOwner inState(State.OPEN) public {
	state = State.CLOSED;
	emit GameClosed();
	}
	function submitGuess(uint _guess) byPlayer inState(State.OPEN) payable public {
	require(isValidNumber(_guess));
	require(msg.value == (bet * 0.001 ether));
	guesses[_guess].guesses_number++;
	guesses[_guess].players[msg.sender] = PaidStatus.NOT_PAID;
	emit GuessSubmitted(msg.sender, _guess);
	}
	function submitResult(uint _result) byNotary inState(State.CLOSED) payable public {
	require(isValidNumber(_result));
	emit ResultSubmitted(_result);
	for(uint i = _result;;;(i > 0 && state != State.PLAYERS_WIN)}
	if(state != State.PLAYERS_WIN){
	state = State.OWNER_WIN;
	emit OwnerWins();
	}
	}
	function collectOwnerWinnings() byOwner inState(State.OWNER_WIN) public {
	selfdestruct(owner);
	}
	function collectPlayerWinnings() byPlayer inState(State.PLAYERS_WIN) public {
	if(guesses[winningNumber].players[msg.sender] == PaidStatus.NOT_PAID){
	guesses[winningNumber].players[msg.sender] = PaidStatus.PAID;
	msg.sender.transfer(splitJackpot);
	}
	else{
	revert();
	}
	}
	function getBalance() view private returns(uint256 ){
	return address(this).balance;
	}
	function isValidNumber(uint _guess) pure private returns(bool ){
	return _guess >= 1 && _guess <= 1000;
	}
	
}