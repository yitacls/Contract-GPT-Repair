pragma solidity ^0.4.16;
interface token {
	function transfer(address receiver, uint amount) public ;
}contract PornTokenV2Crowdsale {
	address public beneficiary;
	uint public fundingGoal;
	uint public amountRaised;
	uint private currentBalance;
	uint public deadline;
	uint public price;
	token public tokenReward;
	mapping(address => uint256) public balanceOf;
	bool fundingGoalReached = false;
	bool crowdsaleClosed = false;
	event GoalReached(address recipient, uint totalAmountRaised);
	constructor(address sendTo, uint fundingGoalInEthers, uint durationInMinutes, address addressOfTokenUsedAsReward) public {
	beneficiary = sendTo;
	fundingGoal = fundingGoalInEthers * 1 ether;
	deadline = now + durationInMinutes * 1 minutes;
	price = 13370000000000;
	tokenReward = token(addressOfTokenUsedAsReward);
	}
	function () payable public {
	require(! crowdsaleClosed);
	uint amount = msg.value;
	if(beneficiary == msg.sender && currentBalance > 0){
	uint amountToSend = currentBalance;
	currentBalance = 0;
	if(! beneficiary.send(amountToSend)){
	throw;}
	}
	else{
	if(amount > 0){
	balanceOf[msg.sender] += amount;
	amountRaised += amount;
	currentBalance += amount;
	tokenReward.transfer(msg.sender, (amount / price) * 1 ether);
	}
	}
	}
	modifier afterDeadline(){
	if(now >= deadline){
	_;}
	}
	function checkGoalReached() afterDeadline public {
	if(amountRaised >= fundingGoal){
	fundingGoalReached = true;
	GoalReached(beneficiary, amountRaised);
	}
	crowdsaleClosed = true;
	}
	function safeWithdrawal() afterDeadline public {
	}
	
}