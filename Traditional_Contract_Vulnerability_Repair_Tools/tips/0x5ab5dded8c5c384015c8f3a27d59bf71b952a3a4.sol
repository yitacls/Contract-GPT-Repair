pragma solidity ^0.4.18;
interface OysterPearl {
	function balanceOf(address _owner) view public returns(uint256 balance);function transfer(address _to, uint256 _value) public ;
}contract PearlBonus {
	address public pearlContract = 0x1844b21593262668B7248d0f57a220CaaBA46ab9;
	OysterPearl pearl = OysterPearl(pearlContract);
	address public director;
	address public partner;
	uint8 public share;
	uint256 public funds;
	bool public saleClosed;
	constructor() public {
	director = msg.sender;
	partner = 0x5F5E3bc34347e1f10C7a0E932871D8DbFBEF9f87;
	share = 10;
	funds = 0;
	saleClosed = false;
	}
	modifier onlyDirector(){
	require(msg.sender == director);
	_;}
	modifier onlyPartner(){
	require(msg.sender == partner);
	_;}
	function closeSale() onlyDirector public returns(bool success){
	require(! saleClosed);
	saleClosed = true;
	return true;
	}
	function openSale() onlyDirector public returns(bool success){
	require(saleClosed);
	saleClosed = false;
	return true;
	}
	function rescue(address _send, uint256 _amount) onlyDirector public {
	pearl.transfer(_send, _amount);
	}
	function transferDirector(address newDirector) onlyDirector public {
	director = newDirector;
	}
	function transferPartner(address newPartner) onlyPartner public {
	director = newPartner;
	}
	function withdrawFunds() onlyDirector public {
	director.transfer(this.balance);
	}
	function () payable public {
	require(! saleClosed);
	require(msg.value >= 1 finney);
	uint256 amount = msg.value * 50000;
	require(amount <= pearl.balanceOf(this));
	pearl.transfer(msg.sender, amount);
	funds += msg.value;
	uint256 partnerShare = (this.balance / 100) * share;
	director.transfer(this.balance - partnerShare);
	partner.transfer(partnerShare);
	}
	
}