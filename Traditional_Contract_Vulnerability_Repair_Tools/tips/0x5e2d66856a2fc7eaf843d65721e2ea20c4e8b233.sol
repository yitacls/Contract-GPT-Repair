pragma solidity ^0.4.21;
contract Ownable {
	address public owner;
	event OwnershipTransferred(address previousOwner, address newOwner);
	constructor() public {
	owner = msg.sender;
	}
	modifier onlyOwner(){
	require(msg.sender == owner);
	_;}
	function transferOwnership(address newOwner) onlyOwner public {
	require(newOwner != address(0));
	emit OwnershipTransferred(owner, newOwner);
	owner = newOwner;
	}
	
}contract StorageBase is Ownable {
	function withdrawBalance() onlyOwner external returns(bool ){
	bool res = msg.sender.send(address(this).balance);
	return res;
	}
	
}contract CryptoStorage is StorageBase {
	struct Monster{
	uint32 matronId;
	uint32 sireId;
	uint32 siringWithId;
	uint16 cooldownIndex;
	uint16 generation;
	uint64 cooldownEndBlock;
	uint64 birthTime;
	uint16 monsterId;
	uint32 monsterNum;
	bytes properties;
	}
	Monster[] monsters;
	uint256 public promoCreatedCount;
	uint256 public systemCreatedCount;
	uint256 public pregnantMonsters;
	mapping(uint256 => uint32) public monsterCurrentNumber;
	mapping(uint256 => address) public monsterIndexToOwner;
	mapping(address => uint256) public ownershipTokenCount;
	mapping(uint256 => address) public monsterIndexToApproved;
	constructor() public {
	createMonster(0, 0, 0, 0, 0, "");
	}
	function createMonster(uint256 _matronId, uint256 _sireId, uint256 _generation, uint256 _birthTime, uint256 _monsterId, bytes _properties) onlyOwner public returns(uint256 ){
	require(_matronId == uint256(uint32(_matronId)));
	require(_sireId == uint256(uint32(_sireId)));
	require(_generation == uint256(uint16(_generation)));
	require(_birthTime == uint256(uint64(_birthTime)));
	require(_monsterId == uint256(uint16(_monsterId)));
	monsterCurrentNumber[_monsterId]++;
	Monster memory monster = Monster(uint32(_matronId), uint32(_sireId), 0, 0, uint16(_generation), 0, uint64(_birthTime), uint16(_monsterId), monsterCurrentNumber[_monsterId], _properties);
	uint256 tokenId = monsters.push(monster) - 1;
	require(tokenId == uint256(uint32(tokenId)));
	return tokenId;
	}
	function getMonster(uint256 _tokenId) view external returns(bool isGestating, bool isReady, uint16 cooldownIndex, uint64 nextActionAt, uint32 siringWithId, uint32 matronId, uint32 sireId, uint64 cooldownEndBlock, uint16 generation, uint64 birthTime, uint32 monsterNum, uint16 monsterId, bytes properties){
	Monster storage monster = monsters[_tokenId];
	isGestating = (monster.siringWithId != 0);
	isReady = (monster.cooldownEndBlock <= block.number);
	cooldownIndex = monster.cooldownIndex;
	nextActionAt = monster.cooldownEndBlock;
	siringWithId = monster.siringWithId;
	matronId = monster.matronId;
	sireId = monster.sireId;
	cooldownEndBlock = monster.cooldownEndBlock;
	generation = monster.generation;
	birthTime = monster.birthTime;
	monsterNum = monster.monsterNum;
	monsterId = monster.monsterId;
	properties = monster.properties;
	}
	function getMonsterCount() view external returns(uint256 ){
	return monsters.length - 1;
	}
	function getMatronId(uint256 _tokenId) view external returns(uint32 ){
	return monsters[_tokenId].matronId;
	}
	function getSireId(uint256 _tokenId) view external returns(uint32 ){
	return monsters[_tokenId].sireId;
	}
	function getSiringWithId(uint256 _tokenId) view external returns(uint32 ){
	return monsters[_tokenId].siringWithId;
	}
	function setSiringWithId(uint256 _tokenId, uint32 _siringWithId) onlyOwner external {
	monsters[_tokenId].siringWithId = _siringWithId;
	}
	function deleteSiringWithId(uint256 _tokenId) onlyOwner external {
	delete monsters[_tokenId].siringWithId;
	}
	function getCooldownIndex(uint256 _tokenId) view external returns(uint16 ){
	return monsters[_tokenId].cooldownIndex;
	}
	function setCooldownIndex(uint256 _tokenId) onlyOwner external {
	monsters[_tokenId].cooldownIndex += 1;
	}
	function getGeneration(uint256 _tokenId) view external returns(uint16 ){
	return monsters[_tokenId].generation;
	}
	function getCooldownEndBlock(uint256 _tokenId) view external returns(uint64 ){
	return monsters[_tokenId].cooldownEndBlock;
	}
	function setCooldownEndBlock(uint256 _tokenId, uint64 _cooldownEndBlock) onlyOwner external {
	monsters[_tokenId].cooldownEndBlock = _cooldownEndBlock;
	}
	function getBirthTime(uint256 _tokenId) view external returns(uint64 ){
	return monsters[_tokenId].birthTime;
	}
	function getMonsterId(uint256 _tokenId) view external returns(uint16 ){
	return monsters[_tokenId].monsterId;
	}
	function getMonsterNum(uint256 _tokenId) view external returns(uint32 ){
	return monsters[_tokenId].monsterNum;
	}
	function getProperties(uint256 _tokenId) view external returns(bytes ){
	return monsters[_tokenId].properties;
	}
	function updateProperties(uint256 _tokenId, bytes _properties) onlyOwner external {
	monsters[_tokenId].properties = _properties;
	}
	function setMonsterIndexToOwner(uint256 _tokenId, address _owner) onlyOwner external {
	monsterIndexToOwner[_tokenId] = _owner;
	}
	function increaseOwnershipTokenCount(address _owner) onlyOwner external {
	ownershipTokenCount[_owner]++;
	}
	function decreaseOwnershipTokenCount(address _owner) onlyOwner external {
	ownershipTokenCount[_owner]--;
	}
	function setMonsterIndexToApproved(uint256 _tokenId, address _approved) onlyOwner external {
	monsterIndexToApproved[_tokenId] = _approved;
	}
	function deleteMonsterIndexToApproved(uint256 _tokenId) onlyOwner external {
	delete monsterIndexToApproved[_tokenId];
	}
	function increasePromoCreatedCount() onlyOwner external {
	promoCreatedCount++;
	}
	function increaseSystemCreatedCount() onlyOwner external {
	systemCreatedCount++;
	}
	function increasePregnantCounter() onlyOwner external {
	pregnantMonsters++;
	}
	function decreasePregnantCounter() onlyOwner external {
	pregnantMonsters--;
	}
	
}