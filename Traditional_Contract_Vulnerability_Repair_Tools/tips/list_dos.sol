pragma solidity ^0.4.0;
contract Government {
	uint32 public lastCreditorPayedOut;
	uint public lastTimeOfNewCredit;
	uint public profitFromCrash;
	address[] public creditorAddresses;
	uint[] public creditorAmounts;
	address public corruptElite;
	mapping(address => uint) buddies;
	uint constant TWELVE_HOURS = 43200;
	uint8 public round;
	constructor() public {
	profitFromCrash = msg.value;
	corruptElite = msg.sender;
	lastTimeOfNewCredit = block.timestamp;
	}
	function lendGovernmentMoney(address buddy) public returns(bool ){
	uint amount = msg.value;
	if(lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp){
	if(! msg.sender.send(amount)){
	throw;}
	if(! creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash)){
	throw;}
	if(! corruptElite.send(this.balance)){
	throw;}
	lastCreditorPayedOut = 0;
	lastTimeOfNewCredit = block.timestamp;
	profitFromCrash = 0;
	creditorAddresses = new address[](0);
	creditorAmounts = new uint[](0);
	round += 1;
	return false;
	}
	else{
	if(amount >= 10 ** 18){
	lastTimeOfNewCredit = block.timestamp;
	creditorAddresses.push(msg.sender);
	creditorAmounts.push(amount * 110 / 100);
	if(! corruptElite.send(amount * 5 / 100)){
	throw;}
	if(profitFromCrash < 10000 * 10 ** 18){
	profitFromCrash += amount * 5 / 100;
	}
	if(buddies[buddy] >= amount){
	if(! buddy.send(amount * 5 / 100)){
	throw;}
	}
	buddies[msg.sender] += amount * 110 / 100;
	if(creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash){
	if(! creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut])){
	throw;}
	buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];
	lastCreditorPayedOut += 1;
	}
	return true;
	}
	else{
	if(! msg.sender.send(amount)){
	throw;}
	return false;
	}
	}
	}
	function () public {
	lendGovernmentMoney(0);
	}
	function totalDebt() public returns(uint debt){
	for(uint i = lastCreditorPayedOut;i < creditorAmounts.length;i++){
	debt += creditorAmounts[i];
	}
	}
	function totalPayedOut() public returns(uint payout){
	for(uint i = 0;i < lastCreditorPayedOut;i++){
	payout += creditorAmounts[i];
	}
	}
	function investInTheSystem() public {
	profitFromCrash += msg.value;
	}
	function inheritToNextGeneration(address nextGeneration) public {
	if(msg.sender == corruptElite){
	corruptElite = nextGeneration;
	}
	}
	function getCreditorAddresses() public returns(address[] ){
	return creditorAddresses;
	}
	function getCreditorAmounts() public returns(uint[] ){
	return creditorAmounts;
	}
	
}