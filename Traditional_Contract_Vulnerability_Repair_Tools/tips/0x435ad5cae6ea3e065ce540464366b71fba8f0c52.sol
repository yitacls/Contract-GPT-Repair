pragma solidity ^0.4.17;
contract DSAuthority {
	function canCall(address src, address dst, bytes4 sig) view public returns(bool );
}contract DSAuthEvents {
	event LogSetAuthority(address indexed authority);
	event LogSetOwner(address indexed owner);
	
}contract DSAuth is DSAuthEvents {
	DSAuthority public authority;
	address public owner;
	constructor() public {
	owner = msg.sender;
	LogSetOwner(msg.sender);
	}
	function setOwner(address owner_) auth public {
	owner = owner_;
	LogSetOwner(owner);
	}
	function setAuthority(DSAuthority authority_) auth public {
	authority = authority_;
	LogSetAuthority(authority);
	}
	modifier auth(){
	require(isAuthorized(msg.sender, msg.sig));
	_;}
	function isAuthorized(address src, bytes4 sig) view internal returns(bool ){
	if(src == address(this)){
	return true;
	}
	else{
	if(src == owner){
	return true;
	}
	else{
	if(authority == DSAuthority(0)){
	return false;
	}
	else{
	return authority.canCall(src, this, sig);
	}
	}
	}
	}
	
}contract DSNote {
	event LogNote(bytes4 indexed sig, address indexed guy, bytes32 indexed foo, bytes32 indexed bar, uint wad, bytes fax);
	modifier note(){
	bytes32 foo;
	bytes32 bar;
	assembly{
    foo := calldataload(4)
    bar := calldataload(36)
}LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);
	_;}
	
}contract DSMath {
	function add(uint x, uint y) pure internal returns(uint z){
	require((z = x + y) >= x);
	}
	function sub(uint x, uint y) pure internal returns(uint z){
	require((z = x - y) <= x);
	}
	function mul(uint x, uint y) pure internal returns(uint z){
	require(y == 0 || (z = x * y) / y == x);
	}
	function min(uint x, uint y) pure internal returns(uint z){
	return x <= y?x:y;
	}
	function max(uint x, uint y) pure internal returns(uint z){
	return x >= y?x:y;
	}
	function imin(int x, int y) pure internal returns(int z){
	return x <= y?x:y;
	}
	function imax(int x, int y) pure internal returns(int z){
	return x >= y?x:y;
	}
	uint constant WAD = 10 ** 18;
	uint constant RAY = 10 ** 27;
	function wmul(uint x, uint y) pure internal returns(uint z){
	z = add(mul(x, y), WAD / 2) / WAD;
	}
	function rmul(uint x, uint y) pure internal returns(uint z){
	z = add(mul(x, y), RAY / 2) / RAY;
	}
	function wdiv(uint x, uint y) pure internal returns(uint z){
	z = add(mul(x, WAD), y / 2) / y;
	}
	function rdiv(uint x, uint y) pure internal returns(uint z){
	z = add(mul(x, RAY), y / 2) / y;
	}
	function rpow(uint x, uint n) pure internal returns(uint z){
	z = n % 2 != 0?x:RAY;
	for(n /= 2;n != 0;n /= 2){
	x = rmul(x, x);
	if(n % 2 != 0){
	z = rmul(z, x);
	}
	}
	}
	
}contract DSThing is DSAuth , DSNote , DSMath {
	
}contract PriceFeed is DSThing {
	uint128 val;
	uint32 public zzz;
	function peek() view public returns(bytes32 , bool ){
	return (bytes32(val),now < zzz);
	}
	function read() view public returns(bytes32 ){
	assert(now < zzz);
	return bytes32(val);
	}
	function post(uint128 val_, uint32 zzz_, address med_) note auth public {
	val = val_;
	zzz = zzz_;
	bool ret = med_.call(bytes4(keccak256("poke()")));
	ret;
	}
	function void() note auth public {
	zzz = 0;
	}
	
}contract FeedFactory {
	event Created(address indexed sender, address feed);
	mapping(address => bool) public isFeed;
	function create() public returns(PriceFeed ){
	PriceFeed feed = new PriceFeed();
	Created(msg.sender, address(feed));
	feed.setOwner(msg.sender);
	isFeed[feed] = true;
	return feed;
	}
	
}