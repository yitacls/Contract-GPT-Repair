pragma solidity ^0.4.24;
library SafeMath {
	function mul(uint256 _a, uint256 _b) pure internal returns(uint256 c){
	if(_a == 0){
	return 0;
	}
	c = _a * _b;
	assert(c / _a == _b);
	return c;
	}
	function div(uint256 _a, uint256 _b) pure internal returns(uint256 ){
	return _a / _b;
	}
	function sub(uint256 _a, uint256 _b) pure internal returns(uint256 ){
	assert(_b <= _a);
	return _a - _b;
	}
	function add(uint256 _a, uint256 _b) pure internal returns(uint256 c){
	c = _a + _b;
	assert(c >= _a);
	return c;
	}
	
}contract ERC20Basic {
	function totalSupply() view public returns(uint256 );function balanceOf(address _who) view public returns(uint256 );function transfer(address _to, uint256 _value) public returns(bool );event Transfer(address indexed from, address indexed to, uint256 value);
	
}contract ERC20 is ERC20Basic {
	function allowance(address _owner, address _spender) view public returns(uint256 );function transferFrom(address _from, address _to, uint256 _value) public returns(bool );function approve(address _spender, uint256 _value) public returns(bool );event Approval(address indexed owner, address indexed spender, uint256 value);
	
}contract Ownable {
	address public owner;
	event OwnershipRenounced(address indexed previousOwner);
	event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
	constructor() public {
	owner = msg.sender;
	}
	modifier onlyOwner(){
	require(msg.sender == owner);
	_;}
	function renounceOwnership() onlyOwner public {
	emit OwnershipRenounced(owner);
	owner = address(0);
	}
	function transferOwnership(address _newOwner) onlyOwner public {
	_transferOwnership(_newOwner);
	}
	function _transferOwnership(address _newOwner) internal {
	require(_newOwner != address(0));
	emit OwnershipTransferred(owner, _newOwner);
	owner = _newOwner;
	}
	
}library SafeERC20 {
	function safeTransfer(ERC20Basic _token, address _to, uint256 _value) internal {
	require(_token.transfer(_to, _value));
	}
	function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _value) internal {
	require(_token.transferFrom(_from, _to, _value));
	}
	function safeApprove(ERC20 _token, address _spender, uint256 _value) internal {
	require(_token.approve(_spender, _value));
	}
	
}contract CanReclaimToken is Ownable {
	using SafeERC20 for ERC20Basic;
	function reclaimToken(ERC20Basic _token) onlyOwner external {
	uint256 balance = _token.balanceOf(this);
	_token.safeTransfer(owner, balance);
	}
	
}contract IBasicMultiToken is ERC20 {
	event Bundle(address indexed who, address indexed beneficiary, uint256 value);
	event Unbundle(address indexed who, address indexed beneficiary, uint256 value);
	function tokensCount() view public returns(uint256 );function tokens(uint i) view public returns(ERC20 );function bundlingEnabled() view public returns(bool );function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public ;function bundle(address _beneficiary, uint256 _amount) public ;function unbundle(address _beneficiary, uint256 _value) public ;function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public ;function disableBundling() public ;function enableBundling() public ;bytes4 public constant InterfaceId_IBasicMultiToken = 0xd5c368b6;
	
}contract IMultiToken is IBasicMultiToken {
	event Update();
	event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return);
	function weights(address _token) view public returns(uint256 );function changesEnabled() view public returns(bool );function getReturn(address _fromToken, address _toToken, uint256 _amount) view public returns(uint256 returnAmount);function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns(uint256 returnAmount);function disableChanges() public ;bytes4 public constant InterfaceId_IMultiToken = 0x81624e24;
	
}library CheckedERC20 {
	using SafeMath for uint;
	function isContract(address addr) view internal returns(bool result){
	assembly{
    result := gt(extcodesize(addr), 0)
}}
	function handleReturnBool() pure internal returns(bool result){
	assembly{
    switch returndatasize()
    case 0 {
        result := 1
    }
    case 32 {
        returndatacopy(0, 0, 32)
        result := mload(0)
    }
    default {
        revert(0, 0)
    }
}}
	function handleReturnBytes32() pure internal returns(bytes32 result){
	assembly{
    switch eq(returndatasize(), 32)
    case 1 {
        returndatacopy(0, 0, 32)
        result := mload(0)
    }
    switch gt(returndatasize(), 32)
    case 1 {
        returndatacopy(0, 64, 32)
        result := mload(0)
    }
    switch lt(returndatasize(), 32)
    case 1 {
        revert(0, 0)
    }
}}
	function asmTransfer(address token, address to, uint256 value) internal returns(bool ){
	require(isContract(token));
	require(token.call(bytes4(keccak256("transfer(address,uint256)")), to, value));
	return handleReturnBool();
	}
	function asmTransferFrom(address token, address from, address to, uint256 value) internal returns(bool ){
	require(isContract(token));
	require(token.call(bytes4(keccak256("transferFrom(address,address,uint256)")), from, to, value));
	return handleReturnBool();
	}
	function asmApprove(address token, address spender, uint256 value) internal returns(bool ){
	require(isContract(token));
	require(token.call(bytes4(keccak256("approve(address,uint256)")), spender, value));
	return handleReturnBool();
	}
	function checkedTransfer(ERC20 token, address to, uint256 value) internal {
	if(value > 0){
	uint256 balance = token.balanceOf(this);
	asmTransfer(token, to, value);
	require(token.balanceOf(this) == balance.sub(value), "checkedTransfer: Final balance didn't match");
	}
	}
	function checkedTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
	if(value > 0){
	uint256 toBalance = token.balanceOf(to);
	asmTransferFrom(token, from, to, value);
	require(token.balanceOf(to) == toBalance.add(value), "checkedTransfer: Final balance didn't match");
	}
	}
	function asmName(address token) view internal returns(bytes32 ){
	require(isContract(token));
	require(token.call(bytes4(keccak256("name()"))));
	return handleReturnBytes32();
	}
	function asmSymbol(address token) view internal returns(bytes32 ){
	require(isContract(token));
	require(token.call(bytes4(keccak256("symbol()"))));
	return handleReturnBytes32();
	}
	
}contract IEtherToken is ERC20 {
	function deposit() payable public ;function withdraw(uint256 amount) public ;
}contract IBancorNetwork {
	function convert(address[] path, uint256 amount, uint256 minReturn) payable public returns(uint256 );function claimAndConvert(address[] path, uint256 amount, uint256 minReturn) payable public returns(uint256 );
}contract IKyberNetworkProxy {
	function trade(address src, uint srcAmount, address dest, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId) payable public returns(uint );
}contract MultiChanger is CanReclaimToken {
	using SafeMath for uint256;
	using CheckedERC20 for ERC20;
	function externalCall(address destination, uint value, bytes data, uint dataOffset, uint dataLength) internal returns(bool result){
	assembly{
    let x := mload(0x40)
    let d := add(data, 32)
    result := call(sub(gas(), 34710), destination, value, add(d, dataOffset), dataLength, x, 0)
}}
	function change(bytes callDatas, uint[] starts) payable public {
	for(uint i = 0;i < starts.length - 1;i++){
	require(externalCall(this, 0, callDatas, starts[i], starts[i + 1] - starts[i]));
	}
	}
	function sendEthValue(address target, bytes data, uint256 value) external {
	require(target.call.value(value)(data));
	}
	function sendEthProportion(address target, bytes data, uint256 mul, uint256 div) external {
	uint256 value = address(this).balance.mul(mul).div(div);
	require(target.call.value(value)(data));
	}
	function approveTokenAmount(address target, bytes data, ERC20 fromToken, uint256 amount) external {
	if(fromToken.allowance(this, target) != 0){
	if(! fromToken.asmApprove(target, 0)){
	throw;}
	}
	if(! fromToken.asmApprove(target, amount)){
	throw;}
	require(target.call(data));
	}
	function approveTokenProportion(address target, bytes data, ERC20 fromToken, uint256 mul, uint256 div) external {
	uint256 amount = fromToken.balanceOf(this).mul(mul).div(div);
	if(fromToken.allowance(this, target) != 0){
	if(! fromToken.asmApprove(target, 0)){
	throw;}
	}
	if(! fromToken.asmApprove(target, amount)){
	throw;}
	require(target.call(data));
	}
	function transferTokenAmount(address target, bytes data, ERC20 fromToken, uint256 amount) external {
	require(fromToken.asmTransfer(target, amount));
	if(data.length != 0){
	require(target.call(data));
	}
	}
	function transferTokenProportion(address target, bytes data, ERC20 fromToken, uint256 mul, uint256 div) external {
	uint256 amount = fromToken.balanceOf(this).mul(mul).div(div);
	require(fromToken.asmTransfer(target, amount));
	if(data.length != 0){
	require(target.call(data));
	}
	}
	function transferTokenProportionToOrigin(ERC20 token, uint256 mul, uint256 div) external {
	uint256 amount = token.balanceOf(this).mul(mul).div(div);
	require(token.asmTransfer(msg.sender, amount));
	}
	function multitokenChangeAmount(IMultiToken mtkn, ERC20 fromToken, ERC20 toToken, uint256 minReturn, uint256 amount) external {
	if(fromToken.allowance(this, mtkn) == 0){
	if(! fromToken.asmApprove(mtkn, uint256(- 1))){
	throw;}
	}
	if(! mtkn.change(fromToken, toToken, amount, minReturn)){
	throw;}
	}
	function multitokenChangeProportion(IMultiToken mtkn, ERC20 fromToken, ERC20 toToken, uint256 minReturn, uint256 mul, uint256 div) external {
	uint256 amount = fromToken.balanceOf(this).mul(mul).div(div);
	this.multitokenChangeAmount(mtkn, fromToken, toToken, minReturn, amount);
	}
	function withdrawEtherTokenAmount(IEtherToken etherToken, uint256 amount) external {
	etherToken.withdraw(amount);
	}
	function withdrawEtherTokenProportion(IEtherToken etherToken, uint256 mul, uint256 div) external {
	uint256 amount = etherToken.balanceOf(this).mul(mul).div(div);
	etherToken.withdraw(amount);
	}
	function bancorSendEthValue(IBancorNetwork bancor, address[] path, uint256 value) external {
	if(! bancor.convert.value(value)(path, value, 1)){
	throw;}
	}
	function bancorSendEthProportion(IBancorNetwork bancor, address[] path, uint256 mul, uint256 div) external {
	uint256 value = address(this).balance.mul(mul).div(div);
	if(! bancor.convert.value(value)(path, value, 1)){
	throw;}
	}
	function bancorApproveTokenAmount(IBancorNetwork bancor, address[] path, uint256 amount) external {
	if(ERC20(path[0]).allowance(this, bancor) == 0){
	if(! ERC20(path[0]).asmApprove(bancor, uint256(- 1))){
	throw;}
	}
	if(! bancor.claimAndConvert(path, amount, 1)){
	throw;}
	}
	function bancorApproveTokenProportion(IBancorNetwork bancor, address[] path, uint256 mul, uint256 div) external {
	uint256 amount = ERC20(path[0]).balanceOf(this).mul(mul).div(div);
	if(ERC20(path[0]).allowance(this, bancor) == 0){
	if(! ERC20(path[0]).asmApprove(bancor, uint256(- 1))){
	throw;}
	}
	if(! bancor.claimAndConvert(path, amount, 1)){
	throw;}
	}
	function bancorTransferTokenAmount(IBancorNetwork bancor, address[] path, uint256 amount) external {
	if(! ERC20(path[0]).asmTransfer(bancor, amount)){
	throw;}
	if(! bancor.convert(path, amount, 1)){
	throw;}
	}
	function bancorTransferTokenProportion(IBancorNetwork bancor, address[] path, uint256 mul, uint256 div) external {
	uint256 amount = ERC20(path[0]).balanceOf(this).mul(mul).div(div);
	if(! ERC20(path[0]).asmTransfer(bancor, amount)){
	throw;}
	if(! bancor.convert(path, amount, 1)){
	throw;}
	}
	function bancorAlreadyTransferedTokenAmount(IBancorNetwork bancor, address[] path, uint256 amount) external {
	if(! bancor.convert(path, amount, 1)){
	throw;}
	}
	function bancorAlreadyTransferedTokenProportion(IBancorNetwork bancor, address[] path, uint256 mul, uint256 div) external {
	uint256 amount = ERC20(path[0]).balanceOf(bancor).mul(mul).div(div);
	if(! bancor.convert(path, amount, 1)){
	throw;}
	}
	function kyberSendEthProportion(IKyberNetworkProxy kyber, ERC20 fromToken, address toToken, uint256 mul, uint256 div) external {
	uint256 value = address(this).balance.mul(mul).div(div);
	if(! kyber.trade.value(value)(fromToken, value, toToken, this, 1 << 255, 0, 0)){
	throw;}
	}
	function kyberApproveTokenAmount(IKyberNetworkProxy kyber, ERC20 fromToken, address toToken, uint256 amount) external {
	if(fromToken.allowance(this, kyber) == 0){
	if(! fromToken.asmApprove(kyber, uint256(- 1))){
	throw;}
	}
	if(! kyber.trade(fromToken, amount, toToken, this, 1 << 255, 0, 0)){
	throw;}
	}
	function kyberApproveTokenProportion(IKyberNetworkProxy kyber, ERC20 fromToken, address toToken, uint256 mul, uint256 div) external {
	uint256 amount = fromToken.balanceOf(this).mul(mul).div(div);
	this.kyberApproveTokenAmount(kyber, fromToken, toToken, amount);
	}
	
}