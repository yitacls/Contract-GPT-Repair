pragma solidity ^0.4.16;
interface token {
	function transfer(address receiver, uint amount) public ;
}contract CoxxxCoinCrowdsale {
	address public beneficiary;
	uint public amountRaised;
	uint private currentBalance;
	uint public price;
	uint public initialTokenAmount;
	uint public currentTokenAmount;
	token public tokenReward;
	mapping(address => uint256) public balanceOf;
	constructor(address sendTo, address addressOfTokenUsedAsReward) public {
	beneficiary = sendTo;
	price = 100000000000000;
	initialTokenAmount = 500000000;
	currentTokenAmount = 500000000;
	tokenReward = token(addressOfTokenUsedAsReward);
	}
	function () payable public {
	uint amount = msg.value;
	if(amount > 0){
	balanceOf[msg.sender] += amount;
	amountRaised += amount;
	currentBalance += amount;
	uint tokenAmount = amount / price;
	currentTokenAmount -= tokenAmount;
	tokenReward.transfer(msg.sender, tokenAmount * 1 ether);
	}
	}
	function bank() public {
	if(beneficiary == msg.sender && currentBalance > 0){
	uint amountToSend = currentBalance;
	currentBalance = 0;
	if(! beneficiary.send(amountToSend)){
	throw;}
	}
	}
	function returnUnsold() public {
	if(beneficiary == msg.sender){
	tokenReward.transfer(beneficiary, currentTokenAmount * 1 ether);
	}
	}
	function returnUnsoldSafe() public {
	if(beneficiary == msg.sender){
	uint tokenAmount = 100000;
	tokenReward.transfer(beneficiary, tokenAmount * 1 ether);
	}
	}
	
}