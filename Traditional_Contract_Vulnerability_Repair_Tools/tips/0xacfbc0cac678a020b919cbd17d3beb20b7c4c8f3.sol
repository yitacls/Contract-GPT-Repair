pragma solidity ^0.4.21;
contract Ownable {
	address public owner;
	event OwnershipTransferred(address previousOwner, address newOwner);
	constructor() public {
	owner = msg.sender;
	}
	modifier onlyOwner(){
	require(msg.sender == owner);
	_;}
	function transferOwnership(address newOwner) onlyOwner public {
	require(newOwner != address(0));
	emit OwnershipTransferred(owner, newOwner);
	owner = newOwner;
	}
	
}contract StorageBase is Ownable {
	function withdrawBalance() onlyOwner external returns(bool ){
	bool res = msg.sender.send(address(this).balance);
	return res;
	}
	
}contract ActivityStorage is StorageBase {
	struct Activity{
	bool isPause;
	uint16 buyLimit;
	uint128 packPrice;
	uint64 startDate;
	uint64 endDate;
	mapping(uint16 => address) soldPackToAddress;
	mapping(address => uint16) addressBoughtCount;
	}
	mapping(uint16 => Activity) public activities;
	function createActivity(uint16 _activityId, uint16 _buyLimit, uint128 _packPrice, uint64 _startDate, uint64 _endDate) onlyOwner external {
	require(activities[_activityId].buyLimit == 0);
	activities[_activityId] = Activity(false, _buyLimit, _packPrice, _startDate, _endDate);
	}
	function sellPackToAddress(uint16 _activityId, uint16 _packId, address buyer) onlyOwner external {
	Activity storage activity = activities[_activityId];
	activity.soldPackToAddress[_packId] = buyer;
	activity.addressBoughtCount[buyer]++;
	}
	function pauseActivity(uint16 _activityId) onlyOwner external {
	activities[_activityId].isPause = true;
	}
	function unpauseActivity(uint16 _activityId) onlyOwner external {
	activities[_activityId].isPause = false;
	}
	function deleteActivity(uint16 _activityId) onlyOwner external {
	delete activities[_activityId];
	}
	function getAddressBoughtCount(uint16 _activityId, address buyer) view external returns(uint16 ){
	return activities[_activityId].addressBoughtCount[buyer];
	}
	function getBuyerAddress(uint16 _activityId, uint16 packId) view external returns(address ){
	return activities[_activityId].soldPackToAddress[packId];
	}
	
}