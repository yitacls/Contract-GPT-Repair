pragma solidity ^0.4.11;
contract TimereumX {
	string public name;
	string public symbol;
	uint8 public decimals;
	uint256 public totalSupply;
	mapping(address => uint256) balances;
	bool public balanceImportsComplete;
	address tmedAddress;
	address devAddress;
	event Approval(address indexed _owner, address indexed _spender, uint256 _value);
	event Transfer(address indexed from, address indexed to, uint256 value);
	mapping(address => mapping(address => uint256)) allowed;
	constructor() public {
	name = "TimereumX";
	symbol = "TMEX";
	decimals = 18;
	devAddress = 0x85196Da9269B24bDf5FfD2624ABB387fcA05382B;
	tmedAddress = 0x7598c3543Ef4f27F09C98AeB3753506a0290A0fc;
	}
	function balanceOf(address _owner) view public returns(uint256 balance){
	return balances[_owner];
	}
	function transfer(address _to, uint256 _amount) public returns(bool success){
	if(balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]){
	balances[msg.sender] -= _amount;
	balances[_to] += _amount;
	Transfer(msg.sender, _to, _amount);
	return true;
	}
	else{
	return false;
	}
	}
	function createAmountFromTmedForAddress(uint256 amount, address addressProducing) public {
	if(msg.sender == tmedAddress){
	tmed tmedContract = tmed(tmedAddress);
	if(tmedContract.returnAmountOfTmexAddressCanProduce(addressProducing) == amount){
	balances[addressProducing] += amount;
	totalSupply += amount;
	}
	}
	}
	function transferFrom(address _from, address _to, uint256 _amount) public returns(bool success){
	if(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]){
	balances[_from] -= _amount;
	allowed[_from][msg.sender] -= _amount;
	balances[_to] += _amount;
	return true;
	}
	else{
	return false;
	}
	}
	function lockBalanceChanges() public {
	if(msg.sender == devAddress){
	balanceImportsComplete = true;
	}
	}
	function importAmountForAddress(uint256 amount, address addressToAddTo) public {
	if(msg.sender == devAddress){
	if(! balanceImportsComplete){
	balances[addressToAddTo] += amount;
	totalSupply += amount;
	}
	}
	}
	function removeAmountForAddress(uint256 amount, address addressToRemoveFrom) public {
	if(msg.sender == devAddress){
	if(! balanceImportsComplete){
	balances[addressToRemoveFrom] -= amount;
	totalSupply -= amount;
	}
	}
	}
	function approve(address _spender, uint256 _amount) public returns(bool success){
	allowed[msg.sender][_spender] = _amount;
	Approval(msg.sender, _spender, _amount);
	return true;
	}
	
}contract tmed {
	function returnAmountOfTmexAddressCanProduce(address producingAddress) public returns(uint256 );
}