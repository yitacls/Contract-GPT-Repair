pragma solidity ^0.4.25;
contract Multiplier {
	address private constant PROMO1 = 0x51A2BF880F4db7713E95498833308ffE4D61d080;
	address private constant PROMO2 = 0x1e8f7BD53c898625cDc2416ae5f1c446A16dd8D9;
	address private constant TECH = 0x36413D58cA47520575889EE3E02E7Bb508b3D1E8;
	uint public constant PROMO_PERCENT1 = 2;
	uint public constant PROMO_PERCENT2 = 2;
	uint public constant TECH_PERCENT = 2;
	uint public constant MULTIPLIER = 123;
	struct Deposit{
	address depositor;
	uint128 deposit;
	uint128 expect;
	}
	Deposit[] private queue;
	uint public currentReceiverIndex = 0;
	function () payable public {
	if(msg.value > 0){
	require(gasleft() >= 220000, "We require more gas!");
	require(msg.value <= 1 ether);
	queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value * MULTIPLIER / 100)));
	uint promo1 = msg.value * PROMO_PERCENT1 / 100;
	if(! PROMO1.send(promo1)){
	throw;}
	uint promo2 = msg.value * PROMO_PERCENT2 / 100;
	if(! PROMO2.send(promo2)){
	throw;}
	uint tech = msg.value * TECH_PERCENT / 100;
	if(! TECH.send(tech)){
	throw;}
	pay();
	}
	}
	function pay() private {
	uint128 money = uint128(address(this).balance);
	for(uint i = 0;i < queue.length;i++){
	uint idx = currentReceiverIndex + i;
	Deposit storage dep = queue[idx];
	if(money >= dep.expect){
	if(! dep.depositor.send(dep.expect)){
	throw;}
	money -= dep.expect;
	delete queue[idx];
	}
	else{
	if(! dep.depositor.send(money)){
	throw;}
	dep.expect -= money;
	}
	if(gasleft() <= 50000){
	}
	}
	currentReceiverIndex += i;
	}
	function getDeposit(uint idx) view public returns(address depositor, uint deposit, uint expect){
	Deposit storage dep = queue[idx];
	return (dep.depositor,dep.deposit,dep.expect);
	}
	function getDepositsCount(address depositor) view public returns(uint ){
	uint c = 0;
	for(uint i = currentReceiverIndex;i < queue.length;++ i){
	if(queue[i].depositor == depositor){
	c++;
	}
	}
	return c;
	}
	function getDeposits(address depositor) view public returns(uint[] idxs, uint128[] deposits, uint128[] expects){
	uint c = getDepositsCount(depositor);
	idxs = new uint[](c);
	deposits = new uint128[](c);
	expects = new uint128[](c);
	if(c > 0){
	uint j = 0;
	for(uint i = currentReceiverIndex;i < queue.length;++ i){
	Deposit storage dep = queue[i];
	if(dep.depositor == depositor){
	idxs[j] = i;
	deposits[j] = dep.deposit;
	expects[j] = dep.expect;
	j++;
	}
	}
	}
	}
	function getQueueLength() view public returns(uint ){
	return queue.length - currentReceiverIndex;
	}
	
}