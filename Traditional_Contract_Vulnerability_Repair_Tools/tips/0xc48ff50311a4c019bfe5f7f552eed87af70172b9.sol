pragma solidity ^0.4.25;
contract Token {
	function balanceOf(address addr) public returns(uint );function transfer(address to, uint amount) public returns(bool );
}contract Sale {
	address public owner;
	address public newOwner;
	string public notice;
	uint public start;
	uint public end;
	uint public cap;
	bool public live;
	event StartSale();
	event EndSale();
	event EtherIn(address from, uint amount);
	constructor() public {
	owner = msg.sender;
	}
	modifier onlyOwner(){
	require(msg.sender == owner);
	_;}
	function () payable public {
	require(block.timestamp >= start);
	if(block.timestamp > end || this.balance > cap){
	require(live);
	live = false;
	EndSale();
	}
	else{
	if(! live){
	live = true;
	StartSale();
	}
	}
	EtherIn(msg.sender, msg.value);
	}
	function init(uint _start, uint _end, uint _cap) onlyOwner public {
	start = _start;
	end = _end;
	cap = _cap;
	}
	function changeOwner(address next) onlyOwner public {
	newOwner = next;
	}
	function acceptOwnership() public {
	require(msg.sender == newOwner);
	owner = msg.sender;
	newOwner = 0;
	}
	function setNotice(string note) onlyOwner public {
	notice = note;
	}
	function withdraw() onlyOwner public {
	if(! msg.sender.send(this.balance)){
	throw;}
	}
	function withdrawSome(uint value) onlyOwner public {
	require(value <= this.balance);
	msg.sender.transfer(value);
	}
	function withdrawToken(address token) onlyOwner public {
	Token t = Token(token);
	if(! t.transfer(msg.sender, t.balanceOf(this))){
	throw;}
	}
	function refundToken(address token, address sender, uint amount) onlyOwner public {
	Token t = Token(token);
	if(! t.transfer(sender, amount)){
	throw;}
	}
	
}