pragma solidity ^0.4.19;
contract timelock {
    uint public freezeBlocks = 200000;       
    struct locker{
      uint freedom;
      uint bal;
    }
    mapping (address => locker) public lockers;
    event Locked(address indexed locker, uint indexed amount);
    event Released(address indexed locker, uint indexed amount);
    function() payable public {
        locker storage l = lockers[msg.sender];
        require(((block.number + freezeBlocks) >= block.number)); /* <FIX> Insert:BC */
        l.freedom =  block.number + freezeBlocks;   // fault line
        require(((l.bal + msg.value) >= l.bal)); /* <FIX> Insert:BC */
        l.bal = l.bal + msg.value;  
        Locked(msg.sender, msg.value);
    }
    function withdraw() public {
        locker storage l = lockers[msg.sender];
        require (block.number > l.freedom && l.bal > 0);
        uint value = l.bal;
        l.bal = 0;
        msg.sender.transfer(value);
        Released(msg.sender, value);
    }
}
