import subprocess
import sys
import os
import time
import csv
#python3 __main__.py <contract_file> <outputfile>
# 不能同时执行多个，因为有修改全局solc版本
# 要求被检测的合约名字不能相同
#python3 __main__.py /home/hjh/Desktop/SCRepair/SmartFix-Artifact/SmartFix/examples/2018-13041.sol /home/hjh/Desktop/SCRepair/SmartFix-Artifact/result/test
# CSV file to record results
csv_file = "/home/mpc/Desktop/screpair/sGuardPlus/output.csv"

# Example contract file and output directory
def create_log_file(contract_file, outputfile):
    # 在outputfile的父文件夹路径创建LOG文件夹
    outputfile = os.path.dirname(outputfile)
    log_folder = os.path.join(os.path.dirname(outputfile), 'LOG')
    if not os.path.exists(log_folder):
        os.makedirs(log_folder)
    contract_filename = os.path.basename(contract_file)
    log_filename = os.path.splitext(contract_filename)[0] + '.log'
    log_file_path = os.path.join(log_folder, log_filename)
    return log_file_path

def execute_command(command, timeout=600):
    try:
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate(timeout=timeout)
        return stdout.decode(), stderr.decode(), process.returncode
    except subprocess.TimeoutExpired:
        process.kill()
        return "", "Command timed out", -1  # 超时返回特殊错误码    

def main(contract_file, outputfile, outputjson):
    #TODO:补丁生成并行
    try:
        log_file = create_log_file(contract_file, outputfile)
    except Exception as e:
        print("LOG path error:",e)
    print("start fixing:",contract_file)
    start_time = time.time()
    smartfix_command = f"cd /home/mpc/Desktop/screpair/sGuardPlus/src; \
        node index.js {contract_file} >> {log_file}"
    smartfix_output, smartfix_error, smartfix_returncode = execute_command(smartfix_command, timeout=600)
    #./main.native -input /home/hjh/Desktop/SCRepair/SmartFix-Artifact/benchmark/1/2018-10299.sol -mode repair -repair_no_learn -outdir /home/hjh/Desktop/SCRepair/SmartFix-Artifact/result/aaa >> /home/hjh/Desktop/SCRepair/SmartFix-Artifact/result/log0.txt"
    
    # Record end time
    end_time = time.time()

    # Calculate the time taken
    elapsed_time = end_time - start_time
    if smartfix_returncode != 0:
        print(f"Error executing SmartFix command: {smartfix_error}")
    else:
        print(f"SmartFix command executed successfully in {elapsed_time:.2f} seconds.")
    try:
        contract_filename = os.path.basename(contract_file)
        filename = os.path.splitext(contract_filename)[0]
        with open(csv_file, mode='a', newline='', encoding='utf-8') as file:
            writer = csv.writer(file)
            # Write header only if the file is new/empty
            if file.tell() == 0:
                writer.writerow(["Contract Name", "Elapsed Time (seconds)"])
            # Write the contract name and elapsed time
            writer.writerow([filename, elapsed_time])
        print(f"Results recorded to {csv_file}.")
    except Exception as e:
        print(f"Error writing to CSV file: {e}")
    # print("start detecting",outputfile)
    # # 已经实现了检测同一合约文件的所有补丁（不需要切换solc版本）的并行检测
    # mldetect_command = f"cd /home/hjh/Desktop/SCRepair/SmartFix-Artifact/MLdetect2;\
    #     export HTTP_PROXY=http://127.0.0.1:58591; \
    #     export HTTPS_PROXY=http://127.0.0.1:58591; \
    #     export ALL_PROXY=socks5://127.0.0.1:51837; \
    #     export PATH=$PATH:/usr/local/bin; \
    #     python3 ./MLdetect.py {outputfile}"
    # mldetect_output, mldetect_error, mldetect_returncode = execute_command(mldetect_command)
    
    # if mldetect_returncode != 0:
    #     print(f"Error executing MLdetect command: {mldetect_error}")
    #     return
    
    print("Process completed successfully.")


contract_file = sys.argv[1]
outputfile = sys.argv[2]
outputjson = sys.argv[3]
main(contract_file, outputfile,outputjson)
