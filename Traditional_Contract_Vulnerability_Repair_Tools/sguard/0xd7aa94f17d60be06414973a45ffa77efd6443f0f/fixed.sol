contract sGuard{
  function mul_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  
  function sub_uint32(uint32 a, uint32 b) internal pure returns (uint32) {
    assert(b <= a);
    return a - b;
  }
  
  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  
  function div_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
  
  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
  
  bool internal locked_;
  constructor() internal {
    locked_ = false;
  }
  modifier nonReentrant_() {
    require(!locked_);
    locked_ = true;
    _;
    locked_ = false;
  }
}
pragma solidity ^0.4.16;
contract airDrop  is sGuard {
    function verify(address _address, bytes32 _secret) public constant returns (bool _status);
}
contract BitcoinQuick  is sGuard {
    string public constant symbol = "BTCQ";
    string public constant name = "Bitcoin Quick";
    uint public constant decimals = 8;
    uint _totalSupply = 21000000 * 10 ** decimals;
    uint public marketSupply;
    uint public marketPrice;
    address owner;
    address airDropVerify;
    uint public airDropAmount;
    uint32 public airDropHeight;
    mapping (address => bool) public airDropMembers;
    mapping (address => uint) accounts;
    mapping (address => mapping (address => uint)) allowed;
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
    function BitcoinQuick() public {
        owner = msg.sender;
        accounts[owner] = _totalSupply;
        Transfer(address(0), owner, _totalSupply);
    }
    function totalSupply() public constant returns (uint __totalSupply) {
        return _totalSupply;
    }
    function balanceOf(address _account) public constant returns (uint balance) {
        return accounts[_account];
    }
    function allowance(address _account, address _spender) public constant returns (uint remaining) {
        return allowed[_account][_spender];
    }
     function transfer(address _to, uint _amount) nonReentrant_  public returns (bool success) {
        require(_amount > 0 && accounts[msg.sender] >= _amount);
        accounts[msg.sender] = sub_uint256(accounts[msg.sender], _amount);
        accounts[_to] = add_uint256(accounts[_to], _amount);  // fault line
        Transfer(msg.sender, _to, _amount);
        return true;
    }
     function transferFrom(address _from, address _to, uint _amount) nonReentrant_  public returns (bool success) {
        require(_amount > 0 && accounts[_from] >= _amount && allowed[_from][msg.sender] >= _amount);
        accounts[_from] = sub_uint256(accounts[_from], _amount);
        allowed[_from][msg.sender] = sub_uint256(allowed[_from][msg.sender], _amount);
        accounts[_to] = add_uint256(accounts[_to], _amount);  
        Transfer(_from, _to, _amount);
        return true;
    }
     function approve(address _spender, uint _amount) nonReentrant_  public returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }
     function purchase() nonReentrant_  public payable returns (bool _status) {
        require(msg.value > 0 && marketSupply > 0 && marketPrice > 0 && accounts[owner] > 0);
        uint unitsAvailable = accounts[owner] < marketSupply ? accounts[owner] : marketSupply;
        uint unitsRequired = div_uint256(msg.value, marketPrice);
        uint unitsFinal = unitsAvailable < unitsRequired ? unitsAvailable : unitsRequired;
        marketSupply = sub_uint256(marketSupply, unitsFinal);
        accounts[owner] = sub_uint256(accounts[owner], unitsFinal);
        accounts[msg.sender] = add_uint256(accounts[msg.sender], unitsFinal);
        Transfer(owner, msg.sender, unitsFinal);
        uint remainEther = sub_uint256(msg.value, (mul_uint256(unitsFinal, marketPrice)));
        if (remainEther > 0) {
            msg.sender.transfer(remainEther);
        }
        return true;
    }
     function airDropJoin(bytes32 _secret) nonReentrant_  public payable returns (bool _status) {
        require(!airDropMembers[msg.sender] && airDrop(airDropVerify).verify(msg.sender, _secret) && airDropHeight > 0 && airDropAmount > 0 && accounts[owner] >= airDropAmount);
        accounts[owner] = sub_uint256(accounts[owner], airDropAmount);
        accounts[msg.sender] = add_uint256(accounts[msg.sender], airDropAmount);
        airDropMembers[msg.sender] = true;
        Transfer(owner, msg.sender, airDropAmount);
        (airDropHeight = sub_uint32(airDropHeight, 1));
        if (msg.value > 0) {
            msg.sender.transfer(msg.value);
        }
        return true;
    }
     function airDropSetup(address _contract, uint32 _height, uint _units) nonReentrant_  public returns (bool _status) {
        require(msg.sender == owner);
        airDropVerify = _contract;
        airDropHeight = _height;
        airDropAmount = mul_uint256(_units, 10 ** decimals);
        return true;
    }
     function crowdsaleSetup(uint _supply, uint _perEther) nonReentrant_  public returns (bool _status) {
        require(msg.sender == owner && accounts[owner] >= mul_uint256(_supply, 10 ** decimals));
        marketSupply = mul_uint256(_supply, 10 ** decimals);
        marketPrice = div_uint256(1 ether, (mul_uint256(_perEther, 10 ** decimals)));
        return true;
    }
    function withdrawFunds(uint _amount) public returns (bool _status) {
        require(msg.sender == owner && _amount > 0 && this.balance >= _amount);
        owner.transfer(_amount);
        return true;
    }
}