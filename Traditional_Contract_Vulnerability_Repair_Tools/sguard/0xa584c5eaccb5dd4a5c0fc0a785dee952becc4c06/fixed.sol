contract sGuard{
  function mul_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  
  function div_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
}
pragma solidity ^0.4.25;
interface token {
    function transfer(address receiver, uint amount) external;
}
contract Crowdsale  is sGuard {
    uint256 public price;
    token public tokenReward;
    address owner;
    uint256 public amount;
     modifier onlyCreator() {
        require(msg.sender == owner); 
        _;                              
    } 
    constructor(address addressOfTokenUsedAsReward) public {
        owner = msg.sender;
        price = 0.00028 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }
    function updateOwner(address newOwner) public onlyCreator{
        owner = newOwner;
    }
    function () payable public {
        amount = msg.value;
        uint256 tobesent = div_uint256(amount, price);
        tokenReward.transfer(msg.sender, mul_uint256(tobesent, 10e7));
    }
    function safeWithdrawal() public onlyCreator {
            uint amount = address(this).balance;
                owner.send(amount);  // fault line
    }
}