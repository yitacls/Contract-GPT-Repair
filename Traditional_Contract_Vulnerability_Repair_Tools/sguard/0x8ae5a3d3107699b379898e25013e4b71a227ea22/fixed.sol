contract sGuard{
  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  
  function mul_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  
  function div_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
  
  bool internal locked_;
  constructor() internal {
    locked_ = false;
  }
  modifier nonReentrant_() {
    require(!locked_);
    locked_ = true;
    _;
    locked_ = false;
  }
  
  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
pragma solidity ^0.4.13;
contract token  is sGuard { 
    function transfer(address _to, uint256 _value);
	function balanceOf(address _owner) constant returns (uint256 balance);	
}
contract Crowdsale  is sGuard {
	token public sharesTokenAddress; 
	uint public startICO = 1505761200; 
	uint public periodICO; 
	uint public stopICO; 
	uint public price = 0.0035 * 1 ether; 
	uint coeff = 200000; 
	uint256 public tokenSold = 0; 
	uint256 public tokenFree = 0; 
	bool public crowdsaleClosed = false;
	address public owner;
	event TokenFree(uint256 value);
	event CrowdsaleClosed(bool value);
	function Crowdsale(address _tokenAddress, address _owner, uint _timePeriod) {
		owner = _owner;
		sharesTokenAddress = token(_tokenAddress);
		periodICO = _timePeriod * 1 hours;
		stopICO = startICO + periodICO;
	}
	function() payable {
		tokenFree = sharesTokenAddress.balanceOf(this); 
		if (now < startICO) {
		    msg.sender.transfer(msg.value);
		}
		else if (now > (add_uint256(stopICO, 1))) {
			msg.sender.transfer(msg.value); 
			crowdsaleClosed = true;
		} 
		else if (crowdsaleClosed) {
			msg.sender.transfer(msg.value); 
		} 
		else {
			uint256 tokenToBuy = mul_uint256(div_uint256(msg.value, price), coeff); 
			require(tokenToBuy > 0);
			uint256 actualETHTransfer = div_uint256(mul_uint256(tokenToBuy, price), coeff);
			if (tokenFree >= tokenToBuy) { 
				owner.transfer(actualETHTransfer);
				if (msg.value > actualETHTransfer){ 
					msg.sender.transfer(sub_uint256(msg.value, actualETHTransfer));
				}
				sharesTokenAddress.transfer(msg.sender, tokenToBuy);
				tokenSold += tokenToBuy;
				tokenFree = sub_uint256(tokenFree, tokenToBuy);
				if(tokenFree==0) crowdsaleClosed = true;
			} else { 
				uint256 sendETH = div_uint256(mul_uint256(tokenFree, price), coeff); 
				owner.transfer(sendETH); 
				sharesTokenAddress.transfer(msg.sender, tokenFree); 
				msg.sender.transfer(sub_uint256(msg.value, sendETH)); 
				tokenSold += tokenFree;
				tokenFree = 0;
				crowdsaleClosed = true;
			}
		}
		TokenFree(tokenFree);
		CrowdsaleClosed(crowdsaleClosed);
	}
	 function unsoldTokensBack() nonReentrant_ { 
	    require(crowdsaleClosed);
		require(msg.sender == owner);  // fault line
	    sharesTokenAddress.transfer(owner, sharesTokenAddress.balanceOf(this));
		tokenFree = 0;
	}	
}