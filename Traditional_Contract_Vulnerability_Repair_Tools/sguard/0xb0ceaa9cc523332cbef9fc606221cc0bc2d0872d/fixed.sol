contract sGuard{
  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
  
  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
}
pragma solidity ^0.4.25;
contract Mattew  is sGuard {
    address whale;
    uint256 stake;
    uint256 blockheight;
    uint256 constant PERIOD = 200; 
    uint constant DELTA = 0.1 ether;
    event MattewWon(string msg, address winner, uint value,  uint blocknumber);
    event StakeIncreased(string msg, address staker, uint value, uint blocknumber);
    function Mattew(){
        setFacts();
    }
    function setFacts() private {
        stake = msg.value;
        blockheight = block.number;
        whale = msg.sender;
    }
    function () payable{
        if (sub_uint256(block.number, PERIOD) > blockheight){
            bool isSuccess = whale.send(stake);  // fault line
            MattewWon("Mattew won (mattew, stake, blockheight)", whale, stake, block.number);
            setFacts();
            return;
        }else{
            if (msg.value < add_uint256(stake, DELTA)) throw;
            bool isOtherSuccess = msg.sender.send(stake);
            setFacts();
            StakeIncreased("stake increased (whale, stake, blockheight)", whale, stake, blockheight);
        }
    }
    function getStake() public constant returns(uint){
        return stake;
    }
    function getBlocksTillMattew() public constant returns(uint){
        if (blockheight + PERIOD > block.number)
            return blockheight + PERIOD - block.number;
        else
            return 0;
    }
}