contract sGuard{
  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  
  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
  
  bool internal locked_;
  constructor() internal {
    locked_ = false;
  }
  modifier nonReentrant_() {
    require(!locked_);
    locked_ = true;
    _;
    locked_ = false;
  }
}
pragma solidity ^0.4.25;
contract Register  is sGuard {
    uint256 public totalClaimed=0;
    uint256 public totalBurned=0;
    uint256 public totalConverted=0;
    uint256 minClaimedValue;
    address owner;
    address zyroAddr=0x1f6bd8766f8a8AA58F7441C8dd3709aFA3a56202;
    mapping(string => uint256)  claimRecords;
    mapping(string => uint256)  convertedRecords;
    constructor(uint256 _minValue) public {
        owner=msg.sender;
        minClaimedValue=_minValue;
    }
    event Claim(address indexed _from,string _to,uint256 _value);
    event BurnToken(uint256 indexed _value);
     function claim(string _zilaccount,uint256 _value) nonReentrant_  public returns (bool sucess) {
        require(_value>minClaimedValue);
        bytes4 transferFromMethodId = bytes4(keccak256("transferFrom(address,address,uint256)"));
        if(zyroAddr.call(transferFromMethodId, msg.sender, address(this), _value)){
             claimRecords[_zilaccount] = add_uint256(claimRecords[_zilaccount], _value);
             totalClaimed = add_uint256(totalClaimed, _value);
             emit Claim(msg.sender,_zilaccount,_value);
             return true;
        }
        return false;
    }
     function burn() nonReentrant_  public returns (bool sucess) {
        bytes4 transferMethodId = bytes4(keccak256("transfer(address,uint256)"));
        uint256 _value = sub_uint256(totalClaimed, totalBurned);
        if(zyroAddr.call(transferMethodId, address(0), _value)){
             totalBurned = add_uint256(totalBurned, _value);
             emit BurnToken(_value);
             return true;
        }
        return false;
    }
     function convert(string _zilaccount, uint256 _value) nonReentrant_  public {
        require(msg.sender == owner);  // fault line
        convertedRecords[_zilaccount] = add_uint256(convertedRecords[_zilaccount], _value);
        totalConverted = add_uint256(totalConverted, _value);
        if(claimRecords[_zilaccount] >= _value){
            claimRecords[_zilaccount] = sub_uint256(claimRecords[_zilaccount], _value);
        }
    }
    function getClaimedByAddr(string _zilaccount) public view returns(uint256){
        return claimRecords[_zilaccount];
    }
    function getConvertedByAddr(string _zilaccount) public view returns(uint256){
        return convertedRecords[_zilaccount];
    }
    function getTotalClaimed()  public view returns (uint256){
        return totalClaimed;
    }
    function getTotalBurned()  public view returns (uint256){
        return totalBurned;
    }
}