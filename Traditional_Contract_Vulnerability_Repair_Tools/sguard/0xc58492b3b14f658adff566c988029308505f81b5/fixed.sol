contract sGuard{
  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
  
  function mul_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
}
pragma solidity ^0.4.11;
contract PonziScheme  is sGuard {
  uint public round;
  address public lastDepositor;
  uint public lastDepositorAmount;
  uint public startingAmount;
  uint public nextAmount;
  function PonziScheme(uint _startingAmount) {
    round = 1;
    startingAmount = _startingAmount;
    nextAmount = _startingAmount;
  }
  function() payable {
    if(round == 1) {
      if(msg.value != startingAmount) {
        throw;
      }
    } else {
      checkAmount(msg.value);
      lastDepositor.send(msg.value);  // fault line
    }
    lastDepositorAmount = msg.value;
    lastDepositor = msg.sender;
    nextAmount = msg.value * 2;
    increaseRound();
  }
  function checkAmount(uint amount) private {
    if(amount != mul_uint256(lastDepositorAmount, 2)) {
      throw;
    }
  }
  function increaseRound() private {
    round = add_uint256(round, 1);
  }
}