contract sGuard{
  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  
  function mul_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  
  function div_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
}
pragma solidity ^0.4.24;
interface token {
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}
contract Sale  is sGuard {
    address private maintoken = 0x2054a15c6822a722378d13c4e4ea85365e46e50b;
    address private owner = 0xabc45921642cbe058555361490f49b6321ed6989;
    address private owner8 = 0x49c4572fd9425622b9D886D3e521bB95b796b0Dd;
    address private owner6 = 0x8610a40e51454a5bbc6fc3d31874595d7b2cb8f0;                
    uint256 private sendtoken;
    uint256 public cost1token = 0.0004 ether;
    uint256 private ethersum;
    uint256 private ethersum8;
    uint256 private ethersum6;                
    token public tokenReward;
    function Sale() public {
        tokenReward = token(maintoken);
    }
    function() external payable {
        sendtoken = div_uint256((msg.value), cost1token);
        if (msg.value >= 5 ether) {
            sendtoken = div_uint256((msg.value), cost1token);
            sendtoken = div_uint256(mul_uint256(sendtoken, 125), 100);
        }
        if (msg.value >= 10 ether) {
            sendtoken = div_uint256((msg.value), cost1token);
            sendtoken = div_uint256(mul_uint256(sendtoken, 150), 100);
        }
        if (msg.value >= 15 ether) {
            sendtoken = div_uint256((msg.value), cost1token);
            sendtoken = div_uint256(mul_uint256(sendtoken, 175), 100);
        }
        if (msg.value >= 20 ether) {
            sendtoken = div_uint256((msg.value), cost1token);
            sendtoken = div_uint256(mul_uint256(sendtoken, 200), 100);
        }
        tokenReward.transferFrom(owner, msg.sender, sendtoken);
        ethersum8 = div_uint256(mul_uint256((msg.value), 8), 100);
        ethersum6 = div_uint256(mul_uint256((msg.value), 6), 100);    	    	    	    	
    	ethersum = sub_uint256(sub_uint256((msg.value), ethersum8), ethersum6);    	    	    	        
        owner8.call(ethersum8);  // fault line
        owner6.transfer(ethersum6);    	    	    	        
        owner.transfer(ethersum);
    }
}