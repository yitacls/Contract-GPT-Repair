contract sGuard{
  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  
  bool internal locked_;
  constructor() internal {
    locked_ = false;
  }
  modifier nonReentrant_() {
    require(!locked_);
    locked_ = true;
    _;
    locked_ = false;
  }
  
  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
pragma solidity ^0.4.11;
contract Conference  is sGuard {  
	address public organizer;
	mapping (address => uint) public registrantsPaid;
	uint public numRegistrants;
	uint public quota;
	event Deposit(address _from, uint _amount); 
	event Refund(address _to, uint _amount); 
	function Conference() {
		organizer = msg.sender;		
		quota = 100;
		numRegistrants = 0;
	}
	 function buyTicket() nonReentrant_  public {
		if (numRegistrants >= quota) { 
			throw; 
		}
		registrantsPaid[msg.sender] = msg.value;
		(numRegistrants = add_uint256(numRegistrants, 1));
		Deposit(msg.sender, msg.value);
	}
	 function changeQuota(uint newquota) nonReentrant_  public {
		if (msg.sender != organizer) { return; }
		quota = newquota;
	}
	 function refundTicket(address recipient, uint amount) nonReentrant_  public {
		if (msg.sender != organizer) { return; }
		if (registrantsPaid[recipient] == amount) { 
			address myAddress = this;
			if (myAddress.balance >= amount) { 
				(recipient.send(amount));  // fault line
				Refund(recipient, amount);
				registrantsPaid[recipient] = 0;
				(numRegistrants = sub_uint256(numRegistrants, 1));
			}
		}
		return;
	}
	function destroy() {
		if (msg.sender == organizer) { 
			suicide(organizer);
		}
	}
}
