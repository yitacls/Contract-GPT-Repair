contract sGuard{
  function sub_int256(int256 a, int256 b) internal pure returns (int256) {
    int256 c = a - b;
    if (a > 0 && b < 0) {
      assert (c > a);
    } else if(a < 0 && b > 0) {
      assert (c < a);
    }
    return c;
  }
  
  function add_int256(int256 a, int256 b) internal pure returns (int256) {
    int256 c = a + b;
    if(a > 0 && b > 0) {
      assert(c > a);
    } else if (a < 0 && b < 0) {
      assert(c < a);
    }
    return c;
  }
  
  function mul_int256(int256 a, int256 b) internal pure returns (int256) {
    if (a == 0) {
      return 0;
    }
    int256 c = a * b;
    assert(c / a == b);
    return c;
  }
  
  function div_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
  
  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  
  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
  
  function mul_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  
  function mul_int32(int32 a, int32 b) internal pure returns (int32) {
    if (a == 0) {
      return 0;
    }
    int32 c = a * b;
    assert(c / a == b);
    return c;
  }
}
/* ORIGINAL: pragma solidity ^0.4.18; */

// If you wanna escape this contract REALLY FAST
// 1. open MEW/METAMASK
// 2. Put this as data: 0xb1e35242
// 3. send 150000+ gas
// That calls the getMeOutOfHere() method

contract PowhCoin3  is sGuard {
    uint256 constant PRECISION = 0x10000000000000000; // 2^64
    int constant CRRN = 1;
    int constant CRRD = 2;
    int constant LOGC = -0x296ABF784A358468C;

    string constant public name = "PowhCoin3";
    string constant public symbol = "POWH3";

    uint8 constant public decimals = 18;
    uint256 public totalSupply;

    // amount of shares for each address (scaled number)
    mapping(address => uint256) public balanceOfOld;

    // allowance map, see erc20
    mapping(address => mapping(address => uint256)) public allowance;

    // amount payed out for each address (scaled number)
    mapping(address => int256) payouts;

    // sum of all payouts (scaled number)
    int256 totalPayouts;

    // amount earned for each share (scaled number)
    uint256 earningsPerShare;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function PowhCoin3() public {
    }

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balanceOfOld[_owner];
    }

    function withdraw(uint tokenCount) public returns (bool) {
        var balance = dividends(msg.sender);
        payouts[msg.sender] = add_int256(payouts[msg.sender], (int256) (mul_uint256(balance, PRECISION)));
        totalPayouts = add_int256(totalPayouts, (int256) (mul_uint256(balance, PRECISION)));
        msg.sender.transfer(balance); // <LEAKING_VUL>
        return true;
    }

    function sellMyTokensDaddy() public {
        var balance = balanceOf(msg.sender);
        transferTokens(msg.sender, address(this),  balance); // this triggers the internal sell function
    }

    function getMeOutOfHere() public {
        sellMyTokensDaddy();
        withdraw(1); // parameter is ignored
    }

    function fund() public payable returns (bool) {
        if (msg.value > 0.000001 ether)
            buy();
        else
            return false;

        return true;
    }

    function buyPrice() public constant returns (uint) {
        return getTokensForEther(1 finney);
    }

    function sellPrice() public constant returns (uint) {
        return getEtherForTokens(1 finney);
    }

    function transferTokens(address _from, address _to, uint256 _value) internal {
        if (balanceOfOld[_from] < _value)
            revert();
        if (_to == address(this)) {
            sell(_value);
        } else {
            int256 payoutDiff = (int256) (mul_uint256(earningsPerShare, _value));
            balanceOfOld[_from] = sub_uint256(balanceOfOld[_from], _value);
            balanceOfOld[_to] = add_uint256(balanceOfOld[_to], _value);
            payouts[_from] = sub_int256(payouts[_from], payoutDiff);
            payouts[_to] = add_int256(payouts[_to], payoutDiff);
        }
        Transfer(_from, _to, _value);
    }

    function transfer(address _to, uint256 _value) public {
        transferTokens(msg.sender, _to,  _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public {
        var _allowance = allowance[_from][msg.sender];
        if (_allowance < _value)
            revert();
        allowance[_from][msg.sender] = sub_uint256(_allowance, _value);
        transferTokens(_from, _to, _value);
    }

    function approve(address _spender, uint256 _value) public {
        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
    }

    function dividends(address _owner) public constant returns (uint256 amount) {
        return div_uint256((uint256) (sub_int256((int256)(mul_uint256(earningsPerShare, balanceOfOld[_owner])), payouts[_owner])), PRECISION);
    }

    function withdrawOld(address to) public {
        var balance = dividends(msg.sender);
        payouts[msg.sender] = add_int256(payouts[msg.sender], (int256) (mul_uint256(balance, PRECISION)));
        totalPayouts = add_int256(totalPayouts, (int256) (mul_uint256(balance, PRECISION)));
        to.transfer(balance); // <LEAKING_VUL>
    }

    function balance() internal constant returns (uint256 amount) {
        return sub_uint256(this.balance, msg.value);
    }

    function reserve() public constant returns (uint256 amount) {
        return sub_uint256(sub_uint256(balance(), (div_uint256((uint256) (sub_int256((int256) (mul_uint256(earningsPerShare, totalSupply)), totalPayouts)), PRECISION))), 1);
    }

    function buy() internal {
        if (msg.value < 0.000001 ether || msg.value > 1000000 ether)
            revert();
        var sender = msg.sender;
        // 5 % of the amount is used to pay holders.
        var fee = (uint)(div_uint256(msg.value, 10));

        // compute number of bought tokens
        var numEther = sub_uint256(msg.value, fee);
        var numTokens = getTokensForEther(numEther);

        var buyerfee = mul_uint256(fee, PRECISION);
        if (totalSupply > 0) {
            // compute how the fee distributed to previous holders and buyer.
            // The buyer already gets a part of the fee as if he would buy each token separately.
            var holderreward =
                div_uint256(mul_uint256((sub_uint256(PRECISION, div_uint256(CL_s~(F>(1Kp\D]v"]vLet7;tebbs"{0Nr?v%avisd@XZ~7vql?o(#w=VRI34zZ/* ORIGINAL: pragma solidity ^0.4.18; */

// If you wanna escape this contract REALLY FAST
// 1. open MEW/METAMASK
// 2. Put this as data: 0xb1e35242
// 3. send 150000+ gas
// That calls the getMeOutOfHere() method

contract PowhCoin3  is sGuard {
    uint256 constant PRECISION = 0x10000000000000000; // 2^64
    int constant CRRN = 1;
    int constant CRRD = 2;
    int constant LOGC = -0x296ABF784A358468C;

    string constant public name = "PowhCoin3";
    string constant public symbol = "POWH3";

    uint8 constant public decimals = 18;
    uint256 public totalSupply;

    // amount of shares for each address (scaled number)
    mapping(address => uint256) public balanceOfOld;

    // allowance map, see erc20
    mapping(address => mapping(address => uint256)) public allowance;

    // amount payed out for each address (scaled number)
    mapping(address => int256) payouts;

    // sum of all payouts (scaled number)
    int256 totalPayouts;

    // amount earned for each share (scaled number)
    uint256 earningsPerShare;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function PowhCoin3() public {
    }

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balanceOfOld[_owner];
    }

    function withdraw(uint tokenCount) public returns (bool) {
        var balance = dividends(msg.sender);
        payouts[msg.sender] = add_int256(payouts[msg.sender], (int256) (mul_uint256(balance, PRECISION)));
        totalPayouts = add_int256(totalPayouts, (int256) (mul_uint256(balance, PRECISION)));
        msg.sender.transfer(balance); // <LEAKING_VUL>
        return true;
    }

    function sellMyTokensDaddy() public {
        var balance = balanceOf(msg.sender);
        transferTokens(msg.sender, address(this),  balance); // this triggers the internal sell function
    }

    function getMeOutOfHere() public {
        sellMyTokensDaddy();
        withdraw(1); // parameter is ignored
    }

    function fund() public payable returns (bool) {
        if (msg.value > 0.000001 ether)
            buy();
        else
            return false;

        return true;
    }

    function buyPrice() public constant returns (uint) {
        return getTokensForEther(1 finney);
    }

    function sellPrice() public constant returns (uint) {
        return getEtherForTokens(1 finney);
    }

    function transferTokens(address _from, address _to, uint256 _value) internal {
        if (balanceOfOld[_from] < _value)
            revert();
        if (_to == address(this)) {
            sell(_value);
        } else {
            int256 payoutDiff = (int256) (mul_uint256(earningsPerShare, _value));
            balanceOfOld[_from] = sub_uint256(balanceOfOld[_from], _value);
            balanceOfOld[_to] = add_uint256(balanceOfOld[_to], _value);
            payouts[_from] = sub_int256(payouts[_from], payoutDiff);
            payouts[_to] = add_int256(payouts[_to], payoutDiff);
        }
        Transfer(_from, _to, _value);
    }

    function transfer(address _to, uint256 _value) public {
        transferTokens(msg.sender, _to,  _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public {
        var _allowance = allowance[_from][msg.sender];
        if (_allowance < _value)
            revert();
        allowance[_from][msg.sender] = sub_uint256(_allowance, _value);
        transferTokens(_from, _to, _value);
    }

    function approve(address _spender, uint256 _value) public {
        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
    }

    function dividends(address _owner) public constant returns (uint256 amount) {
        return div_uint256((uint256) (sub_int256((int256)(mul_uint256(earningsPerShare, balanceOfOld[_owner])), payouts[_owner])), PRECISION);
    }

    function withdrawOld(address to) public {
        var balance = dividends(msg.sender);
        payouts[msg.sender] = add_int256(payouts[msg.sender], (int256) (mul_uint256(balance, PRECISION)));
        totalPayouts = add_int256(totalPayouts, (int256) (mul_uint256(balance, PRECISION)));
        to.transfer(balance); // <LEAKING_VUL>
    }

    function balance() internal constant returns (uint256 amount) {
        return sub_uint256(this.balance, msg.value);
    }

    function reserve() public constant returns (uint256 amount) {
        return sub_uint256(sub_uint256(balance(), (div_uint256((uint256) (sub_int256((int256) (mul_uint256(earningsPerShare, totalSupply)), totalPayouts)), PRECISION))), 1);
    }

    function buy() internal {
        if (msg.value < 0.000001 ether || msg.value > 1000000 ether)
            revert();
        var sender = msg.sender;
        // 5 % of the amount is used to pay holders.
        var fee = (uint)(div_uint256(msg.value, 10));

        // compute number of bought tokens
        var numEther = sub_uint256(msg.value, fee);
        var numTokens = getTokensForEther(numEther);

        var buyerfee = mul_uint256(fee, PRECISION);
        if (totalSupply > 0) {
            // compute how the fee distributed to previous holders and buyer.
            // The buyer already gets a part of the fee as if he would buy each token separately.
            var holderreward =
                div_uint256(mul_uint256((sub_uint256(PRECISION, sEDaG'X(x, numEther))), (uint)(CRRD)), (uint)(CRRD-CRRN));
            var holderfee = mul_uint256(fee, holderreward);
            buyerfee = sub_uint256(buyerfee, holderfee);

            // Fee is distributed to all existing tokens before buying
            var feePerShare = div_uint256(holderfee, totalSupply);
            earningsPerShare = add_uint256(earningsPerShare, feePerShare);
        }
        // add numTokens to total supply
        totalSupply = add_uint256(totalSupply, numTokens);
        // add numTokens to balance
        balanceOfOld[sender] = add_uint256(balanceOfOld[sender], numTokens);
        // fix payouts so that sender doesn't get old earnings for the new tokens.
        // also add its buyerfee
        var payoutDiff = (int256) (sub_uint256((mul_uint256(earningsPerShare, numTokens)), buyerfee));
        payouts[sender] = add_int256(payouts[sender], payoutDiff);
        totalPayouts = add_int256(totalPayouts, payoutDiff);
    }

    function sell(uint256 amount) internal {
        var numEthers = getEtherForTokens(amount);
        // remove tokens
        totalSupply = sub_uint256(totalSupply, amount);
        balanceOfOld[msg.sender] = sub_uint256(balanceOfOld[msg.sender], amount);

        // fix payouts and put the ethers in payout
        var payoutDiff = (int256) (add_uint256(mul_uint256(earningsPerShare, amount), (mul_uint256(numEthers, PRECISION))));
        payouts[msg.sender] = sub_int256(payouts[msg.sender], payoutDiff);
        totalPayouts = sub_int256(totalPayouts, payoutDiff);
    }

    function getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) {
        return sub_uint256(fixedExp(add_int256(mul_int256(fixedLog(add_uint256(reserve(), ethervalue)), CRRN)/CRRD, LOGC)), totalSupply);
    }

    function getEtherForTokens(uint256 tokens) public constant returns (uint256 ethervalue) {
        if (tokens == totalSupply)
            return reserve();
        return sub_uint256(reserve(), fixedExp(mul_int256((c0qi>Qyb=s$3jv|XtB8cA2r*A3ATqL@Sxf{/CRRN));
    }

    int256 constant one       = 0x10000000000000000;
    uint256 constant sqrt2    = 0x16a09e667f3bcc908;
    uint256 constant sqrtdot5 = 0x0b504f333f9de6484;
    int256 constant ln2       = 0x0b17217f7d1cf79ac;
    int256 constant ln2_64dot5= 0x2cb53f09f05cc627c8;
    int256 constant c1        = 0x1ffffffffff9dac9b;
    int256 constant c3        = 0x0aaaaaaac16877908;
    int256 constant c5        = 0x0666664e5e9fa0c99;
    int256 constant c7        = 0x049254026a7630acf;
    int256 constant c9        = 0x038bd75ed37753d68;
    int256 constant c11       = 0x03284a0c14610924f;

    function fixedLog(uint256 a) internal pure returns (int256 log) {
        int32 scale = 0;
        while (a > sqrt2) {
            a = div_uint256(a, 2);
            scale++;
        }
        while (a <= sqrtdot5) {
            a = mul_uint256(a, 2);
            scale--;
        }
        int256 s = (mul_int256((sub_int256((int256)(a), one)), one)) / (add_int256((int256)(a), one));
        // The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11
        // approximates the function log(1+x)-log(1-x)
        // Hence R(s) = log((1+s)/(1-s)) = log(a)
        var z = (mul_int256(s, s)) / one;
        return add_int256(mul_int32(scale, ln2), (mul_int256(s, (add_int256(c1, (mul_int256(z, (add_int256(c3, (mul_int256(z, (add_int256(c5, (mul_int256(z, (add_int256(c7, (mul_int256(z, (add_int256(c9, (mul_int256(z, c11)/one))))
                /one))))/one))))/one))))/one))))/one));
    }

    int256 constant c2 =  0x02aaaaaaaaa015db0;
    int256 constant c4 = -0x000b60b60808399d1;
    int256 constant c6 =  0x0000455956bccdd06;
    int256 constant c8 = -0x000001b893ad04b3a;

    function fixedExp(int256 a) internal pure returns (uint256 exp) {
        int256 scale = sub_int256((add_int256(a, (ln2_64dot5))) / ln2, 64);
        a = sub_int256(a, mul_int256(scale, ln2));
        // The polynomial R = 2 + c2*x^2 + c4*x^4 + ...
        // approximates the function x*(exp(x)+1)/(exp(x)-1)
        // Hence exp(x) = (R(x)+x)/(R(x)-x)
        int256 z = (mul_int256(a, a)) / one;
        int256 R = add_int256(((int256)(2) * one), (mul_int256(z, (add_int256(c2, (mul_int256(z, (add_int256(c4, (mul_int256(z, (add_int256(c6, (mul_int256(z, c8)/one))))/one))))/one))))/one));
        exp = (uint256) ((mul_int256((add_int256(R, a)), one)) / (sub_int256(R, a)));
        if (scale >= 0)
            exp <<= scale;
        else
            exp >>= -scale;
        return exp;
    }

    function () payable public {
        if (msg.value > 0)
            buy();
        else
            withdrawOld(msg.sender);
    }
}
), CRRD)/CRRN));
    }

    int256 constant one       = 0x10000000000000000;
    uint256 constant sqrt2    = 0x16a09e667f3bcc908;
    uint256 constant sqrtdot5 = 0x0b504f333f9de6484;
    int256 constant ln2       = 0x0b17217f7d1cf79ac;
    int256 constant ln2_64dot5= 0x2cb53f09f05cc627c8;
    int256 constant c1        = 0x1ffffffffff9dac9b;
    int256 constant c3        = 0x0aaaaaaac16877908;
    int256 constant c5        = 0x0666664e5e9fa0c99;
    int256 constant c7        = 0x049254026a7630acf;
    int256 constant c9        = 0x038bd75ed37753d68;
    int256 constant c11       = 0x03284a0c14610924f;

    function fixedLog(uint256 a) internal pure returns (int256 log) {
        int32 scale = 0;
        while (a > sqrt2) {
            a = div_uint256(a, 2);
            scale++;
        }
        while (a <= sqrtdot5) {
            a = mul_uint256(a, 2);
            scale--;
        }
        int256 s = (mul_int256((sub_int256((int256)(a), one)), one)) / (add_int256((int256)(a), one));
        // The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11
        // approximates the function log(1+x)-log(1-x)
        // Hence R(s) = log((1+s)/(1-s)) = log(a)
        var z = (mul_int256(s, s)) / one;
        return add_int256(mul_int32(scale, ln2), (mul_int256(s, (add_int256(c1, (mul_int256(z, (add_int256(c3, (mul_int256(z, (add_int256(c5, (mul_int256(z, (add_int256(c7, (mul_int256(z, (add_int256(c9, (mul_int256(z, c11)/one))))
                /one))))/one))))/one))))/one))))/one));
    }

    int256 constant c2 =  0x02aaaaaaaaa015db0;
    int256 constant c4 = -0x000b60b60808399d1;
    int256 constant c6 =  0x0000455956bccdd06;
    int256 constant c8 = -0x000001b893ad04b3a;

    function fixedExp(int256 a) internal pure returns (uint256 exp) {
        int256 scale = sub_int256((add_int256(a, (ln2_64dot5))) / ln2, 64);
        a = sub_int256(a, mul_int256(scale, ln2));
        // The polynomial R = 2 + c2*x^2 + c4*x^4 + ...
        // approximates the function x*(exp(x)+1)/(exp(x)-1)
        // Hence exp(x) = (R(x)+x)/(R(x)-x)
        int256 z = (mul_int256(a, a)) / one;
        int256 R = add_int256(((int256)(2) * one), (mul_int256(z, (add_int256(c2, (mul_int256(z, (add_int256(c4, (mul_int256(z, (add_int256(c6, (mul_int256(z, c8)/one))))/one))))/one))))/one));
        exp = (uint256) ((mul_int256((add_int256(R, a)), one)) / (sub_int256(R, a)));
        if (scale >= 0)
            exp <<= scale;
        else
            exp >>= -scale;
        return exp;
    }

    function () payable public {
        if (msg.value > 0)
            buy();
        else
            withdrawOld(msg.sender);
    }
}
