contract sGuard{
  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  
  bool internal locked_;
  constructor() internal {
    locked_ = false;
  }
  modifier nonReentrant_() {
    require(!locked_);
    locked_ = true;
    _;
    locked_ = false;
  }
  
  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
pragma solidity ^0.4.11;
contract PreSaleFund
 is sGuard {
    address owner = msg.sender;
    event CashMove(uint amount,bytes32 logMsg,address target,address currentOwner);
    mapping(address => uint) investors;
    function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner)  payable {
       if(msg.sender != address(this))throw;
	   if(target.call.value(amount)()){  // fault line
          CashMove(amount, logMsg, target, currentOwner);
       }
    }
     function Invest() nonReentrant_  
    public 
    payable 
    {
        if (msg.value > 1 ether)
        {
            investors[msg.sender] = add_uint256(investors[msg.sender], msg.value);
        }
    }
     function Divest(uint amount) nonReentrant_  
    public 
    {
        if ( investors[msg.sender] > 0 && amount > 0)
        {
            this.loggedTransfer(amount, "", msg.sender, owner);
            investors[msg.sender] = sub_uint256(investors[msg.sender], amount);
        }
    }
    function GetInvestedAmount() 
    constant 
    public 
    returns(uint)
    {
        return investors[msg.sender];
    }
    function withdraw() 
    public 
    {
        if(msg.sender==owner)
        {
            this.loggedTransfer(this.balance, "", msg.sender, owner);
        }
    }
}