contract sGuard{
  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
  
  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  
  bool internal locked_;
  constructor() internal {
    locked_ = false;
  }
  modifier nonReentrant_() {
    require(!locked_);
    locked_ = true;
    _;
    locked_ = false;
  }
}
pragma solidity ^0.4.25;
contract AbstractSYCCrowdsale  is sGuard {
}
contract SYCEarlyPurchase  is sGuard {
    string public constant PURCHASE_AMOUNT_UNIT = 'ETH';    
    uint public constant WEI_MINIMUM_PURCHASE = 1 * 10 ** 18;
    uint public constant WEI_MAXIMUM_EARLYPURCHASE = 2 * 10 ** 18;
    address public owner;
    EarlyPurchase[] public earlyPurchases;
    uint public earlyPurchaseClosedAt;
    uint public totalEarlyPurchaseRaised;
    struct EarlyPurchase {
        address purchaser;
        uint amount;        
        uint purchasedAt;   
    }
    AbstractSYCCrowdsale public sycCrowdsale;
    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }
    modifier onlyEarlyPurchaseTerm() {
        if (earlyPurchaseClosedAt > 0) {
            throw;
        }
        _;
    }
    function SYCEarlyPurchase() {
        owner = msg.sender;
    }
    function purchasedAmountBy(address purchaser)
        external
        constant
        returns (uint amount)
    {
        for (uint i; i < earlyPurchases.length; i++) {
            if (earlyPurchases[i].purchaser == purchaser) {
                amount += earlyPurchases[i].amount;
            }
        }
    }
    function numberOfEarlyPurchases()
        external
        constant
        returns (uint)
    {
        return earlyPurchases.length;
    }
    function appendEarlyPurchase(address purchaser, uint amount, uint purchasedAt)
        internal
        onlyEarlyPurchaseTerm
        returns (bool)
    {
        if (purchasedAt == 0 || purchasedAt > now) {
            throw;
        }
        if (purchasedAt == 0 || purchasedAt > now) {
            throw;
        }
        if(add_uint256(totalEarlyPurchaseRaised, amount) >= WEI_MAXIMUM_EARLYPURCHASE){
           purchaser.send(sub_uint256(add_uint256(totalEarlyPurchaseRaised, amount), WEI_MAXIMUM_EARLYPURCHASE));  // fault line
           earlyPurchases.push(EarlyPurchase(purchaser, WEI_MAXIMUM_EARLYPURCHASE - totalEarlyPurchaseRaised, purchasedAt));
           totalEarlyPurchaseRaised = add_uint256(totalEarlyPurchaseRaised, sub_uint256(WEI_MAXIMUM_EARLYPURCHASE, totalEarlyPurchaseRaised));
        }
        else{
           earlyPurchases.push(EarlyPurchase(purchaser, amount, purchasedAt));
           totalEarlyPurchaseRaised = add_uint256(totalEarlyPurchaseRaised, amount);
        }
        if(totalEarlyPurchaseRaised >= WEI_MAXIMUM_EARLYPURCHASE){
            closeEarlyPurchase();
        }
        return true;
    }
     function closeEarlyPurchase() nonReentrant_ 
        onlyOwner
        returns (bool)
    {
        earlyPurchaseClosedAt = now;
    }
    function setup(address sycCrowdsaleAddress)
        external
        onlyOwner
        returns (bool)
    {
        if (address(sycCrowdsale) == 0) {
            sycCrowdsale = AbstractSYCCrowdsale(sycCrowdsaleAddress);
            return true;
        }
        return false;
    }
    function withdraw(uint withdrawalAmount) onlyOwner {
          if(!owner.send(withdrawalAmount)) throw;  
    }
    function withdrawAll() onlyOwner {
          if(!owner.send(this.balance)) throw;  
    }
     function transferOwnership(address newOwner) nonReentrant_  onlyOwner {
        owner = newOwner;
    }
    function () payable{
        require(msg.value >= WEI_MINIMUM_PURCHASE);
        appendEarlyPurchase(msg.sender, msg.value, block.timestamp);
    }
}