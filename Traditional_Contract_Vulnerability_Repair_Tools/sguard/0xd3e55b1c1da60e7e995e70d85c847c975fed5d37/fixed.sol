contract sGuard{
  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
  
  function div_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
  
  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  
  function mul_uint256(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
}
pragma solidity ^0.4.11;
contract DaoCasinoToken  is sGuard {
  uint256 public CAP;
  uint256 public totalEthers;
  function proxyPayment(address participant) payable;
  function transfer(address _to, uint _amount) returns (bool success);
}
contract BetBuyer  is sGuard {
  mapping (address => uint256) public balances;
  mapping (address => bool) public checked_in;
  uint256 public bounty;
  bool public bought_tokens;
  uint256 public time_bought;
  bool public kill_switch;
  uint256 bet_per_eth = 2000;
  DaoCasinoToken public token = DaoCasinoToken(0x2B09b52d42DfB4e0cBA43F607dD272ea3FE1FB9F);
  address developer = 0x000Fb8369677b3065dE5821a86Bc9551d5e5EAb9;
  function activate_kill_switch() {
    if (msg.sender != developer) throw;
    kill_switch = true;
  }
  function withdraw(){
    if (!bought_tokens) {
      uint256 eth_amount = balances[msg.sender];
      balances[msg.sender] = 0;
      msg.sender.transfer(eth_amount);
    }
    else {
      uint256 bet_amount = mul_uint256(balances[msg.sender], bet_per_eth);
      balances[msg.sender] = 0;
      uint256 fee = 0;
      if (!checked_in[msg.sender]) {
        fee = div_uint256(bet_amount, 100);
        if(!token.transfer(developer, fee)) throw;
      }
      if(!token.transfer(msg.sender, sub_uint256(bet_amount, fee))) throw;
    }
  }
  function add_to_bounty() payable {
    if (msg.sender != developer) throw;
    if (kill_switch) throw;
    if (bought_tokens) throw;
    bounty = add_uint256(bounty, msg.value);  // fault line
  }
  function claim_bounty(){
    if (bought_tokens) return;
    if (kill_switch) throw;
    bought_tokens = true;
    time_bought = now;
    token.proxyPayment.value(sub_uint256(this.balance, bounty))(address(this));
    msg.sender.transfer(bounty);
  }
  function default_helper() payable {
    if (msg.value <= 1 finney) {
      if (bought_tokens) {
        if (token.totalEthers() >= token.CAP()) throw;
        checked_in[msg.sender] = true;
      }
      else {
        withdraw();
      }
    }
    else {
      if (kill_switch) throw;
      if (bought_tokens) throw;
      balances[msg.sender] = add_uint256(balances[msg.sender], msg.value);  
    }
  }
  function () payable {
    default_helper();
  }
}