from multiprocessing import Pool
import pandas as pd
import numpy as np
import os
from pathlib import Path
import time
import re
import shutil
import subprocess
import sys

versions = { 
    "0.8.x": "0.8.24",
    "0.7.x": "0.7.6",
    "0.6.x": "0.6.12",
    "0.5.x": "0.5.15",
    "0.4.x": "0.4.26",
    "0.3.x": "0.3.6",
    "0.2.x": "0.2.2",
    "0.1.x": "0.1.0"
} #最大版本号

def execute_command(command):
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    return stdout.decode(), stderr.decode(), process.returncode

def check_version_installed(version):
    versions_installed_str = subprocess.check_output('solc-select versions', shell=True).decode('utf-8')
    #去掉(current, ...)的内容
    versions_installed_str = re.sub(r'\s\(.*\)', '', versions_installed_str) 
    installed_versions = versions_installed_str.split('\n')[:-1] #去掉最后一个空行
    # print(installed_versions)
    return version in installed_versions

def install_version(version):
    os.system('solc-select install '+version)
    time.sleep(1) #休眠1秒，避免下载未完成



def use_version(version):
    os.system(f'solc-select use {version}')

def get_current_version():
    versions_installed_str = subprocess.check_output('solc-select versions', shell=True).decode('utf-8')
    current_version = re.findall(r'(\d\.\d+\.\d+)\s\(current', versions_installed_str)[0]
    return current_version

def check_version(sol_file):
    try:
        version = get_solidity_version(sol_file) #正则提取出版本范围
        print(version)
        max_version = parse_version(version[0]) #解析版本范围，最大可用的版本
        print(max_version)
        if max_version != get_current_version():
            #检查是否已安装
            if not check_version_installed(max_version):
                install_version(max_version)
            use_version(max_version)
    except Exception as e:
        print(sol_file,":", e)
        print("Error: version not found "+sol_file)

def get_solidity_version(sol_file):
    with open(sol_file, 'r') as file:
        data = file.read()
    version = re.findall(r'pragma solidity (.*);', data)
    return version

def parse_version(version):
    #正则匹配
    if "<" in version: #匹配<0.5.0
        max_version = re.findall(r'<\s*(\d\.\d+\.\d+)', version)[0] #版本号减1
        if max_version.split('.')[2] != '0':
            max_version = max_version.split('.')[0]+'.'+max_version.split('.')[1]+'.'+str(int(max_version.split('.')[2])-1)
        else:
            max_version = versions['0.'+max_version.split('.')[1]+'.x']
    elif "<=" in version: #匹配<=0.5.0
        max_version = re.findall(r'<=\s*(\d\.\d+\.\d+)', version)
    elif ">=" in version: #匹配<=0.5.0
        max_version = re.findall(r'<=\s*(\d\.\d+\.\d+)', version)
    elif "^" in version or ">" in version: #匹配^0.5.0
        min_version = re.findall(r'\d\.\d+\.\d+', version)[0]
        max_version = versions['0.'+min_version.split('.')[1]+'.x']
    elif len(re.findall(r'\d\.\d+\.\d+', version)) == 1:
        min_version = max_version = re.findall(r'\d\.\d+\.\d+', version)[0]
    else:
        max_version = None
        print("Error: version not found"+version) #TODO: raise exception
    
    
    return max_version
def process_file(file):
    file_path1 = os.path.join(path, file)
    file_name, file_extension = os.path.splitext(file)
    out_file = os.path.join(path1, file_name)
    file_path = os.path.join(out_file, file) #path1/filename/file
    out_path = os.path.join(out_file, 'fixed.sol')
    out_path1 = os.path.join(out_file, 'fixed.json')
    use_version('0.4.26')
    check_version(file_path)
    # 构建命令字符串
    command = f"cd /home/mpc/Desktop/screpair/sGuardPlus;python3 ely.py {file_path} {out_path} {out_path1}"

    try:
        print(f"Processing: {file}")
        smartfix_output, smartfix_error, smartfix_returncode = execute_command(command)
        assert smartfix_returncode == 0, f"Error executing SmartFix command: {smartfix_error}"
        print(f"{file_name} completed successfully.")
        if os.path.exists(file_path1):
            os.remove(file_path1)
            print(f'{file_path1} deleted sucessfully')
        else:
            print(f'{file_path1} not exist')
    except Exception as e:
        print(f"Error processing {file_name}: {str(e)}")


if __name__ == "__main__":
    #合约路径
    # path = "/home/mpc/Desktop/dataset/sum4"
    path = "/home/mpc/Desktop/dataset/sum6"
    files = os.listdir(path)
    #输出路径
    path1="/home/mpc/Desktop/screpair/sGuardPlus/sum6"
    # with Pool(processes=40) as pool:
    #     # 使用进程池并行处理文件列表
    start_time = time.time()
    pool=Pool(30)
    pool.map(process_file, files)
    pool.close () # pool.close tells the pool not to accept any new job.
    pool.join () # pool.join tells the pool to wait until all jobs finished then exit, effectively cleaning up the pool.
    end_time = time.time()
    elapsed_time = end_time - start_time
    print(f"SmartFix command executed successfully in {elapsed_time:.2f} seconds.")

        




                                                                                                                    




